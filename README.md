|TreePre-order TraversalTree / Binary Tree / Depth-First Search / RecursionE144CodeBinary Tree Preorder TraversalPreorder traversal traverses the tree structure in this order: Root -> Left -> Right. One aspect of preorder/inorder/postorder traversal that might not be immediately obvious is we are processing subtrees in the same order as a parent-children subtree. So from the root we process the root and then the whole left subtree then the whole right subtree. And also at a leaf node we process the leaf, then the left child, then the right child. This understanding is important for many problems that require you to do/calculate something from each subtree.Concept: 1) Use preorder traversal to print the nodes in a preorder fashion.Tree / N-ary Tree / Depth-First Search / RecursionE589CodeN-ary Tree Preorder TraversalThe space complexity is dependent on what someone considers to be extra space. Some people say data structures that store the output values are considered a part of the space complexity, while others don't. If the output array is counted, it is O(N) space copmlexity. If not, it is O(H) where H is the height of the tree (for the call stack). If an iterate BFS is done, it's always O(N) because the max size of the level in the BFS will have about N nodes in the queue. These tradeoffs are important to understand and should be able to be articulated in an interview.Concept: 1) Use pre-order traversal to traverse an n-ary tree.Tree / Binary Tree / Depth-First Search / RecursionE617Merge Two Binary TreesConcept: 1) Preorder traversal. 2) Traverse two trees at the same time in the same positions even if one tree does not have a node in this position.Tree / Binary Tree / Depth-First Search / RecursionE100CodeSame TreeWe might prefer the iterative DFS or BFS approach over the recursive DFS approach if stack space is an issue. Otherwise, the recursive DFS implementation Is way more clean and concise. If the tree is height-balanced, space complexity is O(logn) for the call stack of the DFS implementation. It is worth noting that I almost always omit iterative DFS solutions from explanations because the translation is trivial in most cases.Concept: 1) Use preorder traversal on two trees simultaneously, comparing the node values at each node. 2) Use boolean evaluation.Tree / Binary Tree / Depth-First Search / RecursionM1448CodeCount Good Nodes in Binary TreeThis is a standard DFS traversal problem of a tree with a subpattern of keeping track of a count outside of the nested function and returning nothing from the DFS. It is a preorder traversal because we process the current node, then dfs on left then dfs on right. Notice how path_max is passed by value, so each execution context gets its own copy of path_max.Concept: 1) Use pre-order traversal to evaluate if the path to the current node has no nodes with a value greater than it.Tree / Binary Tree / Depth-First SearchE257CodeBinary Tree PathsCur_path is a list so in python it is passed by reference. This means that every execution context for each recursive call gets a reference to the same list. So when the call stack pops back up, we are still pointing ot the list that has that extra node in it. So we pop from cur_path to make sure each execution context has the corresponding path. The space complexity O(H) is for the call stack. If we consider the output array paths, then it would be closer to O(N*H) since there can be about N paths of height H.Concept: 1) Use preorder traversal to print each root to leaf path. 2) Build the current path using a list parameter and preorder traversal (add to path first, then check if this node is a leaf). 3) Check if node is a leaf node.In-order TraversalTree / Binary Tree / Depth-First Search / RecursionE94CodeBinary Tree Inorder TraversalInorder traversal traverses a tree structure in a Left -> Root -> Right sequence. The code might be hard to trace if you are not familiar with recursion. The visual of the code doesn't really reflect what is happening during program execution. I recommend watching a video that goes through the traversal if you are not able to visualize each step of the traversal.Concept: 1) Use in-order traversal to print the nodes in an in-order fashion.Tree / Binary Tree / Depth-First Search / RecursionE783CodeMinimum Distance Between BST NodesThe reason we do an inorder traversal is because the minimum difference between two nodes will always be between two nodes that are adjacent in sorted order. This similar to LC 285, but we are checking all successors, so a full inorder traversal is necessary. The reason we use a nonlocal variable outside of the dfs function is because the adjacent values aren't always directly connected by one edge, so we can't use something like a parent reference and must keep track of the last evaluated node. Think of how inorder works. Left -> Root -> Right. So it goes deep left, processes left, processes root, then processes right. The next value in the inorder traversal if there a more nodes in the tree is right's parent's parent, since right is in the left subtree of the Left -> Root -> Right traversal.Concept: 1) Use in-order traversal with a nonlocal variable tracking the previous node's value to find the minimum difference between two nodes.Tree / Binary Tree / Depth-First Search / RecursionM173CodeBinary Search Tree IteratorTo suspend the iterator on the next node, use a stack and populate it with all left nodes until we reach a null node. Then when next() is called, popping the node at the top of the stack will be the next node in the iterator. Then get the node's right reference (if it is not None) and again traverse down to the left, adding each node to the stack. This acts like inorder DFS where we suspend the iterator at the next node.Concept: 1) Use a stack to implement iterative in-order traversal.Post-order TraversalTree / Binary Tree / Depth-First Search / RecursionE145CodeBinary Tree Postorder TraversalConcept: 1) Use post-order traversal to print the nodes in a tree in a post-order fashion.Tree / Binary Tree / Depth-First Search / RecursionE110CodeBalanced Binary TreeA somewhat tricky thing to come up with is returning a pair of values for each recursive call. Also note that this approach requires a helper function because isBalanced() returns a bool. So we can't use isBalanced() to pass the pair of values up the tree during recursion and eventually to the original caller which only wants a bool value.Concept: 1) Use post-order traversal to compare subtree heights.Tree / Binary Tree / Depth-First Search / RecursionM1325CodeDelete Leaves With a Given ValueUse a postorder traversal. We want postorder so we can remove references of leaf nodes that match the target value starting from the bottom and going up. Since we are reassigning references, we can recursively set root.left and root.right to the respective DFS calls. And since we are assigning infromation to each child, we must return some information. And that infromation is the children nodes. So we encode the case that we want to delete by returning None, which will in turn set root.left or root.right to None if they should be deleted. Otherwise, we return root. And the base case returns None if root is None because we want root.left/root.right to be assigned to None if there is no node.Concept: 1) Use post-order traversal to delete leaf nodes that match a target value. 2) Deleting a leaf node can make its parent a leaf node, making a bottom-up order beneficial.Tree / Binary Tree / Depth-First Search / RecursionM236CodeLowest Common Ancestor of a Binary TreeConcept: 1) Use post-order traversal to find the LCA of two nodes.Tree / Binary Tree / Depth-First Search / RecursionM2265CodeCount Nodes Equal to Average of SubtreeThis is a problem that follows the subpattern of processing nodes in a postorder manner. We recurse deeply on the left, then on the right, store whatever information we get from the left and right subtrees into variables, and then use the left and right subtree values we found to compute what the problem is asking for. Important things to note for these types of problems: 1) We return a value in the recursion (a pair of values in this case) even in the base case. 2) We do a preorder traversal and store the values returned by the left and right subtrees in variables 'left' and 'right'. 3) We do a computation on the information we found in the two subtrees. 4) We return a value in the recursion to this execution context's caller (a pair of values in this case).Concept: 1) use post-order traversal to find the average of the values of each node's left and right subtrees and compare it against the current node's value.Tree / Binary Tree / Depth-First Search / RecursionH124CodeBinary Tree Maximum Path SumThis is considered a postorder traversal because we traverse the left subtree, then right subtree, then we process the current. When returning in the DFS, we get max between cur, cur + left and cur + right because it's more explicit so it's easier to trace and understand, but the singular cur.val is not needed since negatives are changed to 0. If the tree is height-balanced, space complexity is O(logn) for the call stack.Concept: 1) Use post-order traversal to find the maximum path sum that goes through every node and its subtrees.Level-order TraversalTree / Binary Tree / Breadth-First Search / RecursionM102CodeBinary Tree Level Order TraversalThis is a standard BFS traversal on a tree. If you are asked to do some type of processing of a tree structure level-wise, it will always be a BFS traversal. It is nearly identical in form to doing a BFS on a graph.Concept: Use level-order traversal to traverse a binary tree.Tree / N-ary Tree / Breadth-First Search / RecursionM429CodeN-ary Tree Level Order TraversalConcept: Use level-order traversal to traverse an n-ary tree.Tree / Binary Tree / Breadth-First Search / RecursionM1161CodeMaximum Level Sum of a Binary TreeMake sure the level_sum > max_level_sum check is > not >= because we want the minimum level. If we update based on if they are equal too, we are then taking the maximum level.Concept: Use level-order traversal to traverse a binary tree, tracking the sum of all node values of each level.Vertical-order TraversalTree / Binary Tree / Hash Map / Depth-First Search / RecursionH987CodeVertical Order Traversal of a Binary TreeThe time complexity comes from the sorting of the columns and the rows when creating the result array that we return. A difficult part of the problem (at least for me) is traversing the dictionary to get the result. Not often are you required to sort keys in a dictionary, so not having this knowledge might push you to a different approach entirely which might be harder to implement. This is why knowing the data structures in your language and how to manipulate them is very important.Concept: 1) Get the vertical ordering of a binary tree by using a column-to-row mapping. Similar to LC 314.Binary Search TreeTree / Binary Search Tree / Depth-First Search / RecursionE700CodeSearch in a Binary Search TreeFor time complexity, it is O(log(N)) if the tree is height-balanced and O(N) if it is not. Using the iterative traversal uses O(1) space because we do not need stack space for the function calls. As for recursion, the worst-case would be if the value we are looking for is a leaf node. No matter what, this scenario would yield a space complexity of O(H) due to the stack frames needed for each function call.Concept: 1) Use binary search to find a target value in a binary search tree.Tree / Binary Search Tree / Depth-First Search / RecursionM98CodeValidate Binary Search TreeAll we have to do is keep a running minimum and maximum bound for each recursive call in the DFS as parameters, update them accordingly and check cur.val against them. To evaluate the boolean value of all subtrees, we need evaluate the left and right subtrees at each root. This is a very common subpattern of preorder traversal where we have a base case that returns a result and another case that acts as the processing part for the preorder traversal before dfs on left and right are called. Then we return left AND right, so True is only returned if all subtrees evaluate to True.Concept: 1) Use preorder traversal to check if each node in a binary search tree is valid. 2) Use boolean evaluation for the return statement.Tree / Binary Search Tree / Depth-First Search / RecursionM235CodeLowest Common Ancestor of a Binary Search TreeDifferent from finding LCA of a tree that does not have the BST property because we know the upper bound of values in the left subtree and the lower bound of values in the right subtree at each root node of each subtree.Concept: 1) Use the BST property to check what subtree a target value is in relation to the current value. 2) Lowest common ancestor.Tree / Binary Search Tree / Depth-First Search / RecursionM701CodeInsert into a Binary Search TreeThe idea for this algorithm is to greedily search for an insert position at a position at the bottom of the tree that will make it a leaf. For the recursive function, there is no need to return anything because we are just updating a reference. For the iterative approach, we can iterate while True because we are guaranteed to reach a leaf node. Both approaches greedily converge to an insert position and look ahead to see if the reference in the correct direction is None.Concept: 1) Use binary search to search for an insert position and insert a new node with a given value.Tree / Binary Search Tree / Depth-First Search / RecursionM538CodeConvert BST to Greater TreeThis traversal is considered to be reverse inorder traversal. Inorder traversal is Left -> Root -> Right. Reverse inorder is Right -> Root -> Left. To explain why inorder and why reverse: The reason we do inorder traversal because inorder traversal of a BST processes each node in order from smallest to largest. (Keep in mind this is for a BST specifically). And the reason we do it in reverse order is because we want to process the nodes in order from largest to smallest according to the problem statement.Concept: 1) Use reverse in-order traversal to add the postfix sum of the sorted values to each node.Construct TreeArray / Tree / Binary Tree / Depth-First Search / RecursionE108CodeConvert Sorted Array to BSTWe have to use the sorted property of the array along with the relationship between values in a binary search tree to solve the problem. For the root of every subtree in a binary search tree, all of the values in the left subtree are less than the root, while all of the values in the right subtree are greater than the root. Since we want a height-balanced tree, we want the left and right subtrees to be of similar height. So we pick the root to be the middle of the array. Then we set the left child and right child of this root as the middle of the left subarray and right subarray respectively. We will do this recursively. The base case is when nums is empty, we return None.Concept: 1) Convert a sorted array to a binary search tree.Array / Tree / Binary Tree / Depth-First Search / RecursionM105CodeConstruct Binary Tree from Preorder and Inorder TraversalMore explanation: The global 'preorder_index' is helpful because the preorder value is always the next value in the preorder array after a root is created. Root.left and root.right is fairly trivial now since we are only changing the bound respective to its side and we do not include the root value in each bound.Concept: 1) Convert a pre-order array and an in-order array into a binary tree.Tree / Binary Tree / Depth-First Search / RecursionH297CodeSerialize and Deserialize Binary TreeThere are two main ways these functions can be implemented. With DFS and with BFS. I prefer BFS because I think it is way easier to visualize the construction of a tree through BFS. Serialize matches the type of BFS you normally see because it is being done on a tree structure, whereas deserialize is doing BFS on a string. In deserialize it really is just a matter of understanding how to traverse the array to create the nodes and update the references to left and right of each root node. I strongly recommend watching Striver's video (the first 7 minutes) to get a good visualization on how this translation between a tree structure and string is done.Concept: 1) Serialize and deserialize a binary tree.Binary Tree IndicesTree / Binary Tree / Hash Set / Depth-First Search / RecursionM1261CodeFind Elements in a Contaminated Binary TreeThis is similar to problems where you need the index of a node in a tree. One of these other problems is LC 662 - "Maximum Width of Binary Tree". So once we notice that the values of each node in this problem are actually the indices, you just need to know the formulas for calculating them and then this problem becuase fairly trivial. The formulas for each index: Left child = cur val * 2 + 1. Right child = cur val * 2 + 2. These indices can be found either with BFS or DFS. Both implementations use a "self.values" set to store visited indices of nodes, which is important to make the find() function an O(1) lookup.Concept: 1) Binary tree indices.Tree / Binary Tree / Depth-First Search / RecursionM958CodeCheck Completeness of a Binary TreeA helpful trick you can use with binary trees is to calculate the index of each node from top to bottom and left to right. To calculate the node's index in the tree, start the root node at index 0. Then when we call dfs on the children, the left child's index is 2*i+1, while the right child's index is 2*i+2. We can use these indices to check if the last node we saw on the last level is equal to the number of nodes seen - 1. To have access to the last node's index in the last level of the tree, update it when we are at the max height/depth of the tree so far. Since dfs traverses the tree left to right, this is guaranteed to be the rightmost node in the last level of the tree.Concept: 1) Binary tree indices. 2) Complete binary tree definition.Build GraphTree / Binary Tree / Graph / Breadth-First SearchM863CodeAll Nodes Distance K in Binary TreeWe need a visited hash set in the BFS because we have undirected edges in the new adjacency list. This is an important distinction between trees (no cycles) and undirected graphs (cycles). For populating the adjacency list, DFS is simpler and a better average time complexity (if tree is height-balanced because space complexity is O(log(N)) for the call stack instead of O(N) that the queue in BFS uses). For creating adj list with DFS, use cur and parent parameters and add undirected edge to adjacency list if cur and parent are not None. One thing to think about is how this way avoids duplicate edges. Imagine if you made an entry for left and right child at each DFS call.Concept: 1) Convert tree to graph. 2) Use breadth-first search to find distance to target value.Tree / N-ary Tree / Graph / Depth-First Search / Breadth-First Search / RecursionM2368CodeReachable Nodes With RestrictionsThis is a standard DFS/BFS problem with a few extra complexities. The first complexity is checking if a node is restricted or not so we avoid going down this path. To do this efficiently, cast restricted to a set so we can do O(1) lookups for node values. The second complexity is the edges being undirected. Most tree problems provide a tree data structure with ListNodes that have directed edges (left and right typically), so you can only traverse the tree in one direction. But for this problem, we are only provided edges, and these edges are undirected. So when we start from 0 and go down the tree, we have to make sure we aren't going back up the tree and recounting nodes/going into an infinite loop. To avoid this, just use a prev reference for the parent node and make sure the neighbor node we are about to call DFS on isn't the parent of the current node.Concept: 1) Convert tree to graph. 2) Using prev to avoid traversing already traversed nodes, while also avoiding traversing nodes that are restricted. 3) Know how to do this for DFS and BFS (use prev parameter in DFS method signature and use tuples of (cur, prev) as nodes in queue).Node RelationshipsTree / Binary Tree / Breadth-First Search / RecursionE993Cousins in Binary TreeConcept: 1) Cousins in a binary tree.Tree / Binary Tree / Breadth-First Search / RecursionM1315CodeSum of Nodes with Even-Valued GrandparentThis implementation is an improvement on the slightly naïve approach of storing a path array that holds state that describes each node as either even or odd. But this adds an extra O(H) space complexity. For a constant O(1) space complexity, we keep two variables 'parent' and 'grand' to keep track of the even/odd bool for each node's ancestors. A mistake I initially made is trying to update grand to parent before checking 'if grand' in the recursive procedure. We want update grand after 'if grand' because the code assumes parent and grand are already updated before this check.Concept: 1) Grandparents in a binary tree.BacktrackingPermutationsArray / Depth-First Search / Backtracking / RecursionM46CodePermutationsOrder matters with permutations, whereas order does NOT matter with combinations. This is significant because we then have to make sure every ordering is expressed. To do so, we use an array that encodes whether an element in the input collection has been used or not. The for loop inside of each recursive call tries every position for every element.Concept: 1) Generate a list of all the permutations of a given list of numbers.Depth-First Search / Backtracking / RecursionM526CodeBeautiful ArrangementConcept: 1) Count all of the unique permutations that can be made in a range of numbers that follows a constraint. 2) Implicit collection of elements.String/ Depth-First Search / Backtracking / RecursionM784CodeLetter Case PermutationConcept: 1) Generate all permuations of letter cases in a string. 2) Append number or recurse on choice to use lower case and recurse on choice to use upper case.MatrixMatrix / Hash Set / Depth-First Search / Backtracking / RecursionH51CodeN-QueensBase case: if r == n, append the board to the result array. Choice: Iterate for col in the range of the number of rows. If the column passes the valid state check, add it to the state. Otherwise, skip this entire if block (prune res of decision tree). Recursive procedure: backtrack(r + 1).Concept: 1) Generate all permutations of element placements in a 2D matrix that adheres to the constraints.BacktrackingH37CodeSudoku SolverBase case: if r == 9, return True. Constraints: Value in current cell must be unique for its respective row/col/square set and be in the range [1, 9]. Choice: If cell == '.', choose between the values [1, 9] to put in this cell. Pay attention to where the valid state checking is at. For this problem, it is inside the for loop. For word search, it is at the base case. We put it inside the for loop because it is the necessary placement for the execution flow. Why? Because the beginning of the for loop is the entry point for the changing state. This is the first part of the algorithm that sees this new value. The discrepency comes from carrying the state change as a method parameter vs generating it in a for loop. Check if choice meets constraints BEFORE recursing because you can't backtrack from a choice where you add the same number to a set since the set only encodes 1 number and cleaning up this decision by removing it wouldn't work as intended.(Hash map is a workaround, but general idea is to consider checking constraints before recursing).Concept: 1) Generate a permutations of elements in a 2D matrix that adheres to the constraints. 2) If using a set to track choices, check constraint before making the choice since you can't backtrack from the choice of adding a duplicate number to the set.CombinationsString / Hash Map / Depth-First Search / Backtracking / RecursionM17CodeLetter Combinations of Phone #We are asked to get every possible letter combination given digits. Since there is no way to avoid enumerating every possible combination, we can think of this problem as exploring all possible states, which tells us we need to use recursion. Our state is described as the index we are at in the digits string as well as the current combination we have built up. Reaching i == len(digits) signifies we have reached a solution state. The index is the only part of our state that can break the problem constraints (by going beyond the last digit in digits). So we don't need any other valid state checking beyond the base case for appending to res. As for our choices, the for loop handles this. For the backtrack, we just need to pop from combo.Concept: 1) Generate all combinations of letters that can be produced from a phone number. 2) Use a hash map to map numbers to letters so each number's possible choices can be iterated over.Array / Depth-First Search / Backtracking / RecursionM77CodeCombinationsThis is similar to LC 78 - "Subsets" except we want combinations of size k and in the range [1, n].Concept: 1) Generate all combinations with the constraints of combination size and numbers within a range.Array / Depth-First Search / Backtracking / RecursionM39CodeCombination SumOur time complexity O(2^N*N) because we are bounded by N instead of T since we can pick at most N elements if we have an element equal to 1 in the input candidates. The extra N is for copying the combination list we are building up to add it to the output list.Concept: 1) Generate all combinations with the constraints of a target combination sum and possible choices being a list of candidates.Array / String / Hash Map / Depth-First Search / Backtracking / RecursionH1255Maximum Score Words Formed by LettersConcept: 1) Generate a combination of words that has a maximum score. 2) Track and backtrack choices using a count hash map for each used character.Array / Depth-First Search / Backtracking / RecursionM2305Fair Distribution of CookiesEach choice has the potential to put into k buckets. The reason we can't do partition backtracking is because the partitions don't have to be in order. So we instead opt to iterate over the buckets (children) to make a choice to put the current in one of the k buckets.Concept: 1) Bucket backtracking.Array / Depth-First Search / Backtracking / RecursionM473CodeMatchsticks to SquareIn problems like Sudoku Solver, we are recursing through the input collection (board) and iterating through the choice spcae (numbers 1-10). For this problem, it is slightly different. We are recursing through the input collection (matchsticks array) and iterating through the choice space (position in the state collection). The key thing to understand for this problem is we are essentially trying to find the correct combination of matchsticks for each side (bucket) of the square.Concept: 1) Determine if an array partitioned into buckets where each bucket adheres to a constraint.|
