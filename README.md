| Problem Concepts                                      | Dif | #                                                                                                                                                                                                              |                                                                                                                                                                                                                                                  | Problem Title                                          | Time Complexity | Space Complexity | Notes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Extra Notes                                                                                                                                                                                                                                                                                                                                                                                    |
| ----------------------------------------------------- | --- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------ | --------------- | ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| SQL                                                   |     |                                                                                                                                                                                                                |                                                                                                                                                                                                                                                  |                                                        |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/recyclable-and-low-fat-products/description/)[1757](https://leetcode.com/problems/recyclable-and-low-fat-products/description/)                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1757-recyclableAndLowFatProducts.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1757-recyclableAndLowFatProducts.sql)                                       | Recyclable and Low Fat Products                        |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/description/)[2356](https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/description/)             | Code                                                                                                                                                                                                                                             | Number of Unique Subjects Taught by Each Teacher       |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/find-customers-with-positive-revenue-this-year/description/)[1821](https://leetcode.com/problems/find-customers-with-positive-revenue-this-year/description/)                 | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1821-findCustomersWithPositiveRevenueThisYear.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1821-findCustomersWithPositiveRevenueThisYear.sql)             | Find Customers With Positive Revenue this Year         |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/invalid-tweets/description/)[1683](https://leetcode.com/problems/invalid-tweets/description/)                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1683-invalidTweets.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1683-invalidTweets.sql)                                                                   | Invalid Tweets                                         |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/combine-two-tables/description/)[175](https://leetcode.com/problems/combine-two-tables/description/)                                                                          | Code                                                                                                                                                                                                                                             | Combine Two Tables                                     |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | 1741                                                                                                                                                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1741-findTotalTimeSpentByEachEmployee.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1741-findTotalTimeSpentByEachEmployee.sql)                             | Find Total Time Spent by Each Employee                 |                 |                  | We need the aggregate function SUM to sum up in_time and out_time for each employee and subtract them to get the total time for each employee. Since we we are getting the sum for each employee, not all employees, we need to use GROUP BY. Notice that we are asked to compute minutes spent by EACH employee on EACH day. So we GROUP BY event_day and emp_id. It groups all rows with the same event_day and emp_id together and does the aggregate SUM on them. \*\*\*All column names from the SELECT clause which are not used in aggregate functions must also appear in the GROUP BY clause.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | M   | [](https://leetcode.com/problems/apples-oranges/description/)[1445](https://leetcode.com/problems/apples-oranges/description/)                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1445-apples%26Oranges.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1445-apples%26Oranges.sql)                                                             | Apples & Oranges                                       |                 |                  | We need to sum up the difference between apples and oranges on each day. To do this, we can use the aggregate function SUM in conjunction with the conditional function IF. We take the sum of every apple and subtract the sum of every orange. Or another way to write it is, if the fruit is an apple, we add sold_num, otherwise we subtract sold_num. Then to group the sums together by sale date, we do GROUP BY sale_date.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/description/)[1378](https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/description/)                 | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1378-replaceEmployeeIDWithTheUniqueIdentifier.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1378-replaceEmployeeIDWithTheUniqueIdentifier.sql)             | Replace Employee ID With The Unique Identifier         |                 |                  | We want to do select EmployeeUNI.unique_id and Employees.name. And then we do a Employees LEFT JOIN EmployeeUNI because the problem specifies "if a user does not have a unique ID just show null." This means we include all employees. And we join them on id.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/students-with-invalid-departments/description/)[1350](https://leetcode.com/problems/students-with-invalid-departments/description/)                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1350-studentsWithInvalidDepartments.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1350-studentsWithInvalidDepartments.sql)                                 | Students With Invalid Departments                      |                 |                  | We want to have all students, even if their departments don't exist. So this is a LEFT JOIN between Students and Departments ON the department ids. Then we use a WHERE clause to get department ids that are NULL in the table.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | M   | [](https://leetcode.com/problems/drop-type-1-orders-for-customers-with-type-0-orders/description/)[2084](https://leetcode.com/problems/drop-type-1-orders-for-customers-with-type-0-orders/description/)       | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC2084-dropType1OrdersForCustomersWithType0Orders.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC2084-dropType1OrdersForCustomersWithType0Orders.sql)         | Drop Type 1 Orders for Customers With Type 0 Orders    |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/warehouse-manager/description/)[1571](https://leetcode.com/problems/warehouse-manager/description/)                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1571-warehouseManager.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1571-warehouseManager.sql)                                                             | Warehouse Manager                                      |                 |                  | We are looking for the volume for all products for their respective warehouse. This is why we use GROUP BY name. We use the aggregate function SUM to sum up the volume of the total units for each product.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | M   | [](https://leetcode.com/problems/capital-gainloss/description/)[1393](https://leetcode.com/problems/capital-gainloss/description/)                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1393-capitalGainLoss.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1393-capitalGainLoss.sql)                                                               | Capital Gain/Loss                                      |                 |                  | If we are buying, we subtract from the sum of our gains by the price. If we are selling, we add to the sum of our gains by the price. To do this, we use the aggregate function SUM in conjunction with an IF condition and we GROUP BY stock_name.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/daily-leads-and-partners/description/)[1693](https://leetcode.com/problems/daily-leads-and-partners/description/)                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1693-dailyLeadsAndPartners.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1693-dailyLeadsAndPartners.sql)                                                   | Daily Leads and Partners                               |                 |                  | We use the COUNT aggregate function in conjunction with the DISTINCT clause to get the count of distinct lead ids and partner ids.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/all-the-matches-of-the-league/description/)[2339](https://leetcode.com/problems/all-the-matches-of-the-league/description/)                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC2339-allTheMatchesOfTheLeague.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC2339-allTheMatchesOfTheLeague.sql)                                             | All the Matches of the League                          |                 |                  | Do you put filter conditions in the WHERE clause or in ON? For INNER JOIN, it doesn't matter. For OUTER JOIN, it may differ. To clear ambiguity, use this rule of thumb: Use ON clause for pairing rows from two tables, and use WHERE clause for further filtering the paired rows.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | [](https://www.youtube.com/watch?v=f9lbm7HA7pw)[https://www.youtube.com/watch?v=f9lbm7HA7pw](https://www.youtube.com/watch?v=f9lbm7HA7pw)                                                                                                                                                                                                                                                      |
| SQL                                                   | E   | [](https://leetcode.com/problems/rearrange-products-table/description/)[1795](https://leetcode.com/problems/rearrange-products-table/description/)                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1795-rearrangeProductsTable.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1795-rearrangeProductsTable.sql)                                                 | Rearrange Products Table                               |                 |                  | UNION operator combines the result-set of two or more SELECT statements. Every SELECT statement within UNION must have the same number of columns, the columns must have similar data types and the columns in every SELECT statement must also be in the same order. We SELECT 'store1', 'store2', 'store3' as store because we want to get the string store1, not the int value associated with it. Then we use the WHERE clause to make sure we are selecting only this store number's rows for this part of the union.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/bank-account-summary-ii/)[1587](https://leetcode.com/problems/bank-account-summary-ii/)                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1587-bankAccountSummaryII.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1587-bankAccountSummaryII.sql)                                                     | Bank Account Summary II                                |                 |                  | We se the aggregate function SUM to sum up the amount for each account. We can SELECT name and amount without an alias because they are unique to their respective tables. JOIN on Users.account and Transactions.account. We use GROUP BY Users.account for the aggregate function to sum up all rows for each unique account. Note: we can use Users.account or Transactions.account. Since WHERE cannot be used with aggregate functions, we use HAVING to make sure we are selecting balances > 10000.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/convert-date-format/description/)[1853](https://leetcode.com/problems/convert-date-format/description/)                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1853-convertDateFormat.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1853-convertDateFormat.sql)                                                           | Convert Date Format                                    |                 |                  | Use the DATE_FORMAT function with the corresponding values to match the desired format.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | 1623                                                                                                                                                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1623-allValidTripletsThatCanRepresentACountry.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1623-allValidTripletsThatCanRepresentACountry.sql)             | All Valid Triplets That Can Represent a Country        |                 |                  | Simply select all student names from each table and use a WHILE clause to make sure the names and ids are pairwise distinct. The query performs a cartesian product between the three tables, which is why the table with less entries fills up the extra rows. It essentially returns the combination of every row from its table with every row from the other tables. To avoid this, we would use JOIN in conjunction with SELECT. SELECT does cartesian product implicitly if number of rows aren't the same across all the tables being selected from.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/customer-who-visited-but-did-not-make-any-transactions/description/)[1581](https://leetcode.com/problems/customer-who-visited-but-did-not-make-any-transactions/description/) | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1581-customerWhoVisitedButDidNotMakeAnyTransactions.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1581-customerWhoVisitedButDidNotMakeAnyTransactions.sql) | Customer Who Visited but Did Not Make Any Transactions |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/low-quality-problems/)[2026](https://leetcode.com/problems/low-quality-problems/)                                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC2026-low-QualityProblems.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC2026-low-QualityProblems.sql)                                                       | Low-Quality Problems                                   |                 |                  | We can use arithmetic and comparison operators with a WHERE clause. So we do arithmetic and select the row if it is less than .6.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/swap-salary/description/)[627](https://leetcode.com/problems/swap-salary/description/)                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC627-swapSalary.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC627-swapSalary.sql)                                                                           | Swap Salary                                            |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/unique-orders-and-customers-per-month/description/)[1565](https://leetcode.com/problems/unique-orders-and-customers-per-month/description/)                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1565-uniqueOrdersAndCustomersPerMonth.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1565-uniqueOrdersAndCustomersPerMonth.sql)                             | Unique Orders and Customers Per Month                  |                 |                  | To SELECT the month, we can use the date_format function, with the format as year-month.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/immediate-food-delivery-i/description/)[1173](https://leetcode.com/problems/immediate-food-delivery-i/description/)                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1173-immediateFoodDeliveryI.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1173-immediateFoodDeliveryI.sql)                                                 | Immediate Food Delivery I                              |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                |
| SQL                                                   | E   | [](https://leetcode.com/problems/find-the-team-size/description/)[1303](https://leetcode.com/problems/find-the-team-size/description/)                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1303-findTheTeamSize.sql)[Code](https://github.com/BrandonKenter/Solutions/blob/main/SQL/LC1303-findTheTeamSize.sql)                                                               | Find the Team Size                                     |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                |
| Tree                                                  |     |                                                                                                                                                                                                                |                                                                                                                                                                                                                                                  | 36                                                     |                 |                  | Do author's code and author's notes later. "Coming soon".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                |
| Tracking path                                         |     |                                                                                                                                                                                                                |                                                                                                                                                                                                                                                  |                                                        |                 |                  | When tracking the path of a DFS on tree, process the tree in a PREORDER fashion. Append the node to the list, then call DFS on the left and right subtrees. If you need to check if the current node is a leaf node, check if not cur.left and not cur.right before the DFS calls.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                |
| Returning Early                                       |     |                                                                                                                                                                                                                |                                                                                                                                                                                                                                                  |                                                        |                 |                  | Returning early from recursion: There are generally two ways you can approach returning early from recursion: using boolean values or using a nonlocal variable and using the nullity of this global variable to check if you need to return early.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | If returning some value that will either be None if not found or some value if found, and doing postorder assinging a value to left and right, we can do "return left or right". If left evaluates to not None, it will return this value early. If right evaluates to not None, it will return early. And it returns the value, not True/False.                                               |
| Tree / Binary Search Tree                             | \-  | \-                                                                                                                                                                                                             | \-                                                                                                                                                                                                                                               | Introduction to Binary Search Tree                     | \-              | \-               | In general, binary search trees will assume a height of log(N). However, this is not a guarantee and should not be automatically assumed, especially in an interview. Tradeoffs are very important and need to be discussed if you want to give a good signal to your interviewer. When dealing with trees, always clarify if the tree is height-balanced or not. This will affect the space complexity analysis. The BST property is, for every root node, the left child's value should be less than the root's value and the right child's value should be greater than the root's value. This definition can vary slightly depending on if the tree allows for duplicate nodes. Typically then the right node may also have a value equal to the parent. Also, the left and right subtrees need to be a BST.                                                                                                                                                                                                                                                                                                                                                                                                                                            | The BST property is, for every root node, the left child's value should be less than the root's value and the right child's value should be greater than the root's value. This definition can vary slightly depending on if the tree allows for duplicate nodes. Typically then the right node may also have a value equal to the parent. Also, the left and right subtrees need to be a BST. |
| Tree                                                  | \-  | \-                                                                                                                                                                                                             | \-                                                                                                                                                                                                                                               | Requirements Needed to Construct a Unique Binary Tree  | \-              | \-               | What is important is to find what is on the left and right of a root. This is where an inorder list is essential. The reason we can have a preorder or postorder list is because the only thing pre and post changes is from where you start the algorithm on the list, left or right. The root of the tree will be on the left for preorder and will be on the right for postorder.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Need preorder/postorder and inorder lists. We get root from preorder list because that will always be the root. Then we find root in the inorder list. To the left of the root in inorder list will be the left subtree and to the right will be the right subtree.                                                                                                                            |
| Tree                                                  | \-  | \-                                                                                                                                                                                                             |                                                                                                                                                                                                                                                  | Morris Traversal                                       | \-              | \-               | Morris Traversal is an improvement on traversals like preorder/inorder/postorder by requiring O(1) space instead of O(H).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                       |     |                                                                                                                                                                                                                |                                                                                                                                                                                                                                                  |                                                        |                 | Subpattern       | Pre-order Traversal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                |
| Tree / Binary Tree / Depth-First Search / Recursion   | E   | [](https://leetcode.com/problems/binary-tree-preorder-traversal/)[144](https://leetcode.com/problems/binary-tree-preorder-traversal/)                                                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC144-binaryTreePreorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC144-binaryTreePreorderTraversal.py)                                         | Binary Tree Preorder Traversal                         | O(N)            | O(H)             | Preorder traversal traverses the tree structure in this order: Root -> Left -> Right. One aspect of preorder/inorder/postorder traversal that might not be immediately obvious is we are processing subtrees in the same order as a parent-children subtree. So from the root we process the root and then the whole left subtree then the whole right subtree. And also at a leaf node we process the leaf, then the left child, then the right child. This understanding is important for many problems that require you to do/calculate something from each subtree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Use preorder traversal to print the nodes in a preorder fashion.                                                                                                                                                                                                                                                                                                                   |
| Tree / N-ary Tree / Depth-First Search / Recursion    | E   | [](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)[589](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC589-N-aryTreePreorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC589-N-aryTreePreorderTraversal.py)                                           | N-ary Tree Preorder Traversal                          | O(N)            | O(N)             | The space complexity is dependent on what someone considers to be extra space. Some people say data structures that store the output values are considered a part of the space complexity, while others don't. If the output array is counted, it is O(N) space copmlexity. If not, it is O(H) where H is the height of the tree (for the call stack). If an iterate BFS is done, it's always O(N) because the max size of the level in the BFS will have about N nodes in the queue. These tradeoffs are important to understand and should be able to be articulated in an interview.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Use pre-order traversal to traverse an n-ary tree.                                                                                                                                                                                                                                                                                                                                 |
| Tree / Binary Tree / Depth-First Search / Recursion   | E   | [](https://leetcode.com/problems/merge-two-binary-trees/)[617](https://leetcode.com/problems/merge-two-binary-trees/)                                                                                          |                                                                                                                                                                                                                                                  | Merge Two Binary Trees                                 |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Preorder traversal. 2) Traverse two trees at the same time in the same positions even if one tree does not have a node in this position.                                                                                                                                                                                                                                           |
| Tree / Binary Tree / Depth-First Search / Recursion   | E   | [](https://leetcode.com/problems/same-tree/)[100](https://leetcode.com/problems/same-tree/)                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC100-sameTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC100-sameTree.py)                                                                               | Same Tree                                              | O(N)            | O(N)             | We might prefer the iterative DFS or BFS approach over the recursive DFS approach if stack space is an issue. Otherwise, the recursive DFS implementation Is way more clean and concise. If the tree is height-balanced, space complexity is O(logn) for the call stack of the DFS implementation. It is worth noting that I almost always omit iterative DFS solutions from explanations because the translation is trivial in most cases.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use preorder traversal on two trees simultaneously, comparing the node values at each node. 2) Use boolean evaluation.                                                                                                                                                                                                                                                             |
| Tree / Binary Tree / Depth-First Search / Recursion   | M   | [](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)[1448](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1448-countGoodNodesInBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1448-countGoodNodesInBinaryTree.py)                                         | Count Good Nodes in Binary Tree                        | O(N)            | O(N)             | This is a standard DFS traversal problem of a tree with a subpattern of keeping track of a count outside of the nested function and returning nothing from the DFS. It is a preorder traversal because we process the current node, then dfs on left then dfs on right. Notice how path_max is passed by value, so each execution context gets its own copy of path_max.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Concept: 1) Use pre-order traversal to evaluate if the path to the current node has no nodes with a value greater than it.                                                                                                                                                                                                                                                                     |
| Tree / Binary Tree / Depth-First Search               | M   | [](https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/description/)[1457](https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/description/)                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1457-pseudo-PalindromicPathsInABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1457-pseudo-PalindromicPathsInABinaryTree.py)                     | Pseudo-Palindromic Paths in a Binary Tree              | O(N)            | O(1)             | To get to a solution, we have to understand what the upper bound of the number of nodes in the problem description tells us. Having 10^5 nodes means we want an O(N) solution or better because this is the general upper bound for O(N) solutions to pass. So manually doing permutations is obviously way more than O(N). This is where we need to observe and use information from the problem to find an O(N) solution: node values can only be in the range [0, 9]. This means, for every node we traverse, all nodes in the path are in this range. So we can iterate through them in constant time. If it was values in range [0, N], this solution would be O(N^2). The second thing we need to know is palindromes have every element's frequence as either even or all even and 1 odd. We can use a hash map, keep track of counts, and check if the counts represent a pseudo-palindromic path at each leaf.                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Use preorder traversal to process the node value counts along the path to the current node. 2) Keeping track of path node counts using a hash map. 3) Using this counts hash map to determine if a palindrome can be made out of these nodes (only one odd count can exist).                                                                                                       |
| Tree / Binary Tree / Depth-First Search               | E   | [](https://leetcode.com/problems/invert-binary-tree/)[226](https://leetcode.com/problems/invert-binary-tree/)                                                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC226-invertBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC226-invertBinaryTree.py)                                                               | Invert Binary Tree                                     | O(N)            | O(H)             | Swapping left and right is easy in python with the inline swap. Alternatively, you could use an iterative approach with BFS by swapping each of the popped node's left and right references.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Use preorder traversal to swap children node references of the current node and recurse on the children. 2) Return updated root to its caller.                                                                                                                                                                                                                                     |
| Tree / Binary Tree / Depth-First Search               | E   | [](https://leetcode.com/problems/binary-tree-paths/)[257](https://leetcode.com/problems/binary-tree-paths/)                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/binaryTreePaths.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/binaryTreePaths.py)                                                                             | Binary Tree Paths                                      | O(N)            | O(H \* N)        | Cur_path is a list so in python it is passed by reference. This means that every execution context for each recursive call gets a reference to the same list. So when the call stack pops back up, we are still pointing ot the list that has that extra node in it. So we pop from cur_path to make sure each execution context has the corresponding path. The space complexity O(H) is for the call stack. If we consider the output array paths, then it would be closer to O(N\*H) since there can be about N paths of height H.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Use preorder traversal to print each root to leaf path. 2) Build the current path using a list parameter and preorder traversal (add to path first, then check if this node is a leaf). 3) Check if node is a leaf node.                                                                                                                                                           |
| Tree / Binary Tree / Depth-First Search               | E   | [](https://leetcode.com/problems/symmetric-tree/)[101](https://leetcode.com/problems/symmetric-tree/)                                                                                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC101-symmetricTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC101-symmetricTree.py)                                                                     | Symmetric Tree                                         | O(N)            | O(log(N))        | For symmetry, think of a mirror. The virtical line is at the root. The closest nodes to the line on one side should match the closest nodes to the other side, and it expands outwards. To check for symmetry, do a preorder traversal simultaneously on the left and right subtrees. The preorder nature comes from first checking equality in the base cases, then calling DFS on the inner and outer pairs.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Use preorder traversal to check if each node and the node in its mirror position are equal. 2) Understand what it a symmetric tree is and how to visualize it. 3) Use boolean evaluation.                                                                                                                                                                                          |
| Tree / Binary Tree / Depth-First Search               | M   | [](https://leetcode.com/problems/path-sum-iii/)[437](https://leetcode.com/problems/path-sum-iii/)                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC437-pathSumIII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC437-pathSumIII.py)                                                                           | Path Sum III                                           | O(N)            | O(N)             | For each node there are two possible scenarios that could increment count: 1) The sum of the current path equals the target sum. In this case, increment count by 1. 2) There is a continuous path that starts after the root that adds up to the target sum, i.e., cur_sum - target_sum is in the prefix map. In this case, increment count by the number of times this prefix is in the prefix map. We remove the cur_sum entry from the prefix map before popping back up because this specific prefix sum instance will no longer exist in future paths, therefore should not be able to be used in the prefix map.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Use preorder traversal to calculate the sum of the path to the current node. 2) Use a prefix sums hash map to see if a prefix subpath of currentPathSum - targetSum has been seen on the path to the current node.                                                                                                                                                                 |
| Tree / Binary Tree / Depth-First Search               | M   | [](https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/description/)[1372](https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/description/)                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1372-longestZigZagPathInABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1372-longestZigZagPathInABinaryTree.py)                                 | Longest ZigZag Path in a Binary Tree                   | O(N)            | O(1)             | Figuring out a solution to this problem mostly comes down to two things: 1) Choosing postorder vs preorder traversal and 2) Understanding how to update the current path length. For point 1, it can be done either way because updating the current path length for point 2 can be done in both directions. For updating the path length, we must understand that the direction cannot be the same two times in a row. But since we want to enumerate all possible paths, we reset path_len to 1 for the next recursive call because this is now the highest edge that can be a part of the next path, which maximizes the potential future path.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Use preorder traversal to process the zigzag path length to the current node. 2) Calling the recursive function individually for the root's left and right children when the first recursive call requires information about its relation to its parent.                                                                                                                           |
| Tree / DFS                                            | E   | [](https://leetcode.com/problems/sum-of-left-leaves/)[404](https://leetcode.com/problems/sum-of-left-leaves/)                                                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC404-sumOfLeftLeaves.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC404-sumOfLeftLeaves.py)                                                                 | Sum of Left Leaves                                     | O(N)            | O(H)             | We are only doing a preorder traversal of the tree (process root, then recurse on left then recurse on right) and storing information found in a local variable, so we do not need to return any information to the root caller. Knowing when and where to place return statements for each problem is a key step in fully understanding recursion and being able to trace the call stack, so always be aware of how the return statements and flow of the recursive calls work in each approach.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Use pre-order traversal to check if a node is a leaf and is a left child.                                                                                                                                                                                                                                                                                                          |
| Tree / DFS                                            | E   | [](https://leetcode.com/problems/leaf-similar-trees/)[872](https://leetcode.com/problems/leaf-similar-trees/)                                                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC872-leaf-SimilarTrees.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC872-leaf-SimilarTrees.py)                                                             | Leaf-Similar Trees                                     | O(N)            | O(N)             | We can't do BFS because the levels of the leaves can be different. This is something that is easy to overlook or misunderstand. We could do an O(H) space implementation or have just one list for leaves if we care about space.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Use pre-order traversal to check if a node is a leaf and add it to a list of leaves so the leaves can be compared with another tree's leaves.                                                                                                                                                                                                                                      |
| Tree / N-ary Tree / Depth-First Search                | E   | [](https://leetcode.com/problems/maximum-depth-of-n-ary-tree/)[559](https://leetcode.com/problems/maximum-depth-of-n-ary-tree/)                                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC559-maximumDepthOfN-aryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC559-maximumDepthOfN-aryTree.py)                                                 | Maximum Depth of N-ary Tree                            | O(N)            | O(H)             | BFS is worse than DFS in the average case for space complexity because DFS only uses stack space, which is O(H) or height of the tree, whereas BFS uses worst-case space of the number of nodes in the last level of the tree which is O(N).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Use pre-order traversal to traverse an n-ary tree and update the max depth at each node.                                                                                                                                                                                                                                                                                           |
| Tree / Binary Tree / Depth-First Search               | E   | [](https://leetcode.com/problems/path-sum/)[112](https://leetcode.com/problems/path-sum/)                                                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC112-pathSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC112-pathSum.py)                                                                                 | Path Sum                                               | O(N)            | O(H)             | Integers are pass by value, so for each recursive call a copy is created for cur_sum. Each execution context of each recursive call has their own copy of cur_sum. This is why we do not need to subtract from cur_sum when popping back up the recursive call tree (like we would have to do if it was a path list). We do "dfs(left) OR dfs(right)' because the 'or' will cause every call to return to the root caller if just one path has the target_sum.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Use preorder traversal to evaluate path sum at each node. 2) Use boolean evaluation.                                                                                                                                                                                                                                                                                               |
| Tree / DFS                                            | M   | [](https://leetcode.com/problems/path-sum-ii/)[113](https://leetcode.com/problems/path-sum-ii/)                                                                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC113-pathSumII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC113-pathSumII.py)                                                                             | Path Sum II                                            | O(N)            | O(N^2)           | Lists are pass by reference, so for each recursive call the same reference is passed for cur_path. Each execution context of each recursive call has the same copy of cur_path. This is why we need to pop from cur_path before popping back up the recursive call tree. We are traversing the whole tree, so other than the base case we have no return statements to return early. Since we are storing all of the paths that sum up to target_sum, we could have to store a path for every single leaf node, which is O(N^2) space. Some people omit space required to store answers while others don't. Just discuss with the interviewer what it would be in either case. (If you don't consider output space then it is O(H) since cur_path is never bigger than the height of the tree).                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Use preorder traversal to add to the current path data structure (list) at each node.                                                                                                                                                                                                                                                                                              |
| Tree / DFS                                            | E   | [](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/)[1022](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/)                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1022-sumOfRootToLeafBinaryNumbers.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1022-sumOfRootToLeafBinaryNumbers.py)                                     | Sum of Root to Leaf Binary Numbers                     | O(N\*H)         | O(H)             | We use a cur_path array because string concatenation is an O(H) operation for each concatenation, whereas "".join() is an O(H) operation once when we reach a leaf. If the tree is complete, the time complexity becomes O(N\*H) because we have N paths to leaf nodes and each path is of size H wehere H is the height of the tree. It takes O(H) time to join each cur_path and you have to do this N times.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Use pre-order traversal to add to the current path data structure(list) at each node and add to a total path sum at each leaf.                                                                                                                                                                                                                                                     |
| Tree / Binary Tree / Depth-First Search               | M   | [](https://leetcode.com/problems/smallest-string-starting-from-leaf/description/)[988](https://leetcode.com/problems/smallest-string-starting-from-leaf/description/)                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC988-smallestStringStartingFromLeaf.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC988-smallestStringStartingFromLeaf.py)                                   | Smallest String Starting From Leaf                     | O(N)            | O(N^2)           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Use preorder traversal to process the path string to the current node. 2) Comparing strings by lexographic order.                                                                                                                                                                                                                                                                  |
| Tree / DFS                                            | E   | [](https://leetcode.com/problems/univalued-binary-tree/)[965](https://leetcode.com/problems/univalued-binary-tree/)                                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC965-univaluedBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC965-univaluedBinaryTree.py)                                                         | Univalued Binary Tree                                  | O(N)            | O(H)             | This is a standard DFS traversal problem of a tree with a subpattern of returning a bool to the root caller. The difference with this pattern is if we find something that doesn't follow the criteria we are looking for, we return False right away. The 'return dfs on left and dfs on right' statement makes it so if ANY call is evaluated to False, it will immediately stop all future recursive calls and pop everything back up the call stack and return a False. If this never happens, we get to the base case for both dfs on left and dfs on right of the very last node in the right-most subtree and these True values are 'bubbled up' to the root caller and the root call is evaluated to True.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Use post-order traversal to determine if the left and right subtrees of each node are univalued and return this boolean to its caller.                                                                                                                                                                                                                                             |
|                                                       |     |                                                                                                                                                                                                                |                                                                                                                                                                                                                                                  |                                                        |                 | Subpattern       | In-order Traversal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                |
| Tree / Binary Tree / Depth-First Search / Recursion   | E   | [](https://leetcode.com/problems/binary-tree-inorder-traversal/)[94](https://leetcode.com/problems/binary-tree-inorder-traversal/)                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC94-binaryTreeInorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC94-binaryTreeInorderTraversal.py)                                             | Binary Tree Inorder Traversal                          | O(N)            | O(N)             | Inorder traversal traverses a tree structure in a Left -> Root -> Right sequence. The code might be hard to trace if you are not familiar with recursion. The visual of the code doesn't really reflect what is happening during program execution. I recommend watching a video that goes through the traversal if you are not able to visualize each step of the traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) Use in-order traversal to print the nodes in an in-order fashion.                                                                                                                                                                                                                                                                                                                  |
| Tree / Binary Tree / Depth-First Search / Recursion   | E   | [](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)[783](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC783-minimumDistanceBetweenBSTNodes.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC783-minimumDistanceBetweenBSTNodes.py)                                   | Minimum Distance Between BST Nodes                     | O(N)            | O(H)             | The reason we do an inorder traversal is because the minimum difference between two nodes will always be between two nodes that are adjacent in sorted order. This similar to LC 285, but we are checking all successors, so a full inorder traversal is necessary. The reason we use a nonlocal variable outside of the dfs function is because the adjacent values aren't always directly connected by one edge, so we can't use something like a parent reference and must keep track of the last evaluated node. Think of how inorder works. Left -> Root -> Right. So it goes deep left, processes left, processes root, then processes right. The next value in the inorder traversal if there a more nodes in the tree is right's parent's parent, since right is in the left subtree of the Left -> Root -> Right traversal.                                                                                                                                                                                                                                                                                                                                                                                                                        | Concept: 1) Use in-order traversal with a nonlocal variable tracking the previous node's value to find the minimum difference between two nodes.                                                                                                                                                                                                                                               |
| Tree / Binary Tree / Depth-First Search / Recursion   | M   | [](https://leetcode.com/problems/binary-search-tree-iterator/)[173](https://leetcode.com/problems/binary-search-tree-iterator/)                                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC173-binarySearchTreeIterator.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC173-binarySearchTreeIterator.py)                                               | Binary Search Tree Iterator                            | O(N)            | O(H)             | To suspend the iterator on the next node, use a stack and populate it with all left nodes until we reach a null node. Then when next() is called, popping the node at the top of the stack will be the next node in the iterator. Then get the node's right reference (if it is not None) and again traverse down to the left, adding each node to the stack. This acts like inorder DFS where we suspend the iterator at the next node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Concept: 1) Use a stack to implement iterative in-order traversal.                                                                                                                                                                                                                                                                                                                             |
|                                                       |     |                                                                                                                                                                                                                |                                                                                                                                                                                                                                                  |                                                        |                 | Subpattern       | Post-order Traversal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Use when deleting nodes, evaluating expressions such as postfix notation in arithmetic expressions, or when performing calculations on children nodes/subtrees of current node.                                                                                                                                                                                                                |
| Tree / Binary Tree / Depth-First Search / Recursion   | E   | [](https://leetcode.com/problems/binary-tree-postorder-traversal/)[145](https://leetcode.com/problems/binary-tree-postorder-traversal/)                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC145-binaryTreePostorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC145-binaryTreePostorderTraversal.py)                                       | Binary Tree Postorder Traversal                        | O(N)            | O(H)             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Use post-order traversal to print the nodes in a tree in a post-order fashion.                                                                                                                                                                                                                                                                                                     |
| Tree / Binary Tree / Depth-First Search / Recursion   | E   | [](https://leetcode.com/problems/balanced-binary-tree/)[110](https://leetcode.com/problems/balanced-binary-tree/)                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC110-balancedBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC110-balancedBinaryTree.py)                                                           | Balanced Binary Tree                                   | O(N)            | O(N)             | A somewhat tricky thing to come up with is returning a pair of values for each recursive call. Also note that this approach requires a helper function because isBalanced() returns a bool. So we can't use isBalanced() to pass the pair of values up the tree during recursion and eventually to the original caller which only wants a bool value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Use post-order traversal to compare subtree heights.                                                                                                                                                                                                                                                                                                                               |
| Tree / Binary Tree / Depth-First Search / Recursion   | M   | [](https://leetcode.com/problems/delete-leaves-with-a-given-value/description/)[1325](https://leetcode.com/problems/delete-leaves-with-a-given-value/description/)                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1325-deleteLeavesWithAGivenValue.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1325-deleteLeavesWithAGivenValue.py)                                       | Delete Leaves With a Given Value                       | O(N)            | O(H)             | Use a postorder traversal. We want postorder so we can remove references of leaf nodes that match the target value starting from the bottom and going up. Since we are reassigning references, we can recursively set root.left and root.right to the respective DFS calls. And since we are assigning infromation to each child, we must return some information. And that infromation is the children nodes. So we encode the case that we want to delete by returning None, which will in turn set root.left or root.right to None if they should be deleted. Otherwise, we return root. And the base case returns None if root is None because we want root.left/root.right to be assigned to None if there is no node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use post-order traversal to delete leaf nodes that match a target value. 2) Deleting a leaf node can make its parent a leaf node, making a bottom-up order beneficial.                                                                                                                                                                                                             |
| Tree / Binary Tree / Depth-First Search / Recursion   | M   | [](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)[236](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC236-lowestCommonAncestorOfABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC236-lowestCommonAncestorOfABinaryTree.py)                             | Lowest Common Ancestor of a Binary Tree                | O(N)            | O(H)             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Use post-order traversal to find the LCA of two nodes.                                                                                                                                                                                                                                                                                                                             |
| Tree / Binary Tree / Depth-First Search / Recursion   | M   | [](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/)[2265](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/)                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2265-countNodesEqualToAverageOfSubtree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2265-countNodesEqualToAverageOfSubtree.py)                           | Count Nodes Equal to Average of Subtree                | O(N)            | O(H)             | This is a problem that follows the subpattern of processing nodes in a postorder manner. We recurse deeply on the left, then on the right, store whatever information we get from the left and right subtrees into variables, and then use the left and right subtree values we found to compute what the problem is asking for. Important things to note for these types of problems: 1) We return a value in the recursion (a pair of values in this case) even in the base case. 2) We do a preorder traversal and store the values returned by the left and right subtrees in variables 'left' and 'right'. 3) We do a computation on the information we found in the two subtrees. 4) We return a value in the recursion to this execution context's caller (a pair of values in this case).                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) use post-order traversal to find the average of the values of each node's left and right subtrees and compare it against the current node's value.                                                                                                                                                                                                                                 |
| Tree / Binary Tree / Depth-First Search / Recursion   | H   | [](https://leetcode.com/problems/binary-tree-maximum-path-sum/)[124](https://leetcode.com/problems/binary-tree-maximum-path-sum/)                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC124-binaryTreeMaximumPathSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC124-binaryTreeMaximumPathSum.py)                                               | Binary Tree Maximum Path Sum                           | O(N)            | O(N)             | This is considered a postorder traversal because we traverse the left subtree, then right subtree, then we process the current. When returning in the DFS, we get max between cur, cur + left and cur + right because it's more explicit so it's easier to trace and understand, but the singular cur.val is not needed since negatives are changed to 0. If the tree is height-balanced, space complexity is O(logn) for the call stack.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Use post-order traversal to find the maximum path sum that goes through every node and its subtrees.                                                                                                                                                                                                                                                                               |
| Tree / Binary Tree / Depth-First Search               | E   | [](https://leetcode.com/problems/maximum-depth-of-binary-tree/)[104](https://leetcode.com/problems/maximum-depth-of-binary-tree/)                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC104-maximumDepthOfBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC104-maximumDepthOfBinaryTree.py)                                               | Maximum Depth of Binary Tree                           | O(N)            | O(H)             | If the tree is height-balanced, space complexity is O(logn) for the call stack with DFS and will have a better space complexity since the input is not a skew tree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Use post-order traversal to find the maximum depth of each node's left and right subtrees recursively and return the maximum to its caller.                                                                                                                                                                                                                                        |
| Tree / Binary Tree / Depth-First Search               | M   | [](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)[114](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC114-flattenBinaryTreeToLinkedList.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC114-flattenBinaryTreeToLinkedList.py)                                     | Flatten Binary Tree to Linked List                     | O(N)            | O(H)             | If trying to get nodes in preorder traversal manner, do postorder because it's just backwards and then we can use the reference of prev to update reference of current node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Use reverse post-order traversal to update tree node references such that each node's successor in an in-order traversal is its right child.                                                                                                                                                                                                                                       |
| Tree / DFS                                            | M   | [](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/)[1339](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/)                                                       |                                                                                                                                                                                                                                                  | Maximum Product of Splitted Binary Tree                | O(N)            | O(N)             | If the tree is height-balanced, space complexity is O(logn) for the call stack.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Postorder traversal. 2) subtreeSum \* (totalNodeSum - subtreeSum) = product of split binary tree.                                                                                                                                                                                                                                                                                  |
| Tree                                                  | M   | [](https://leetcode.com/problems/house-robber-iii/)[337](https://leetcode.com/problems/house-robber-iii/)                                                                                                      |                                                                                                                                                                                                                                                  | House Robber III                                       |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Use postorder traversal to get the max of taking the curren't node's value or its children's value.                                                                                                                                                                                                                                                                                |
| Tree / Binary Tree / Depth-First Search               | E   | [](https://leetcode.com/problems/diameter-of-binary-tree/)[543](https://leetcode.com/problems/diameter-of-binary-tree/)                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC543-diameterOfBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC543-diameterOfBinaryTree.py)                                                       | Diameter of a Binary Tree                              | O(N)            | O(N)             | The diameter is the number of edges between nodes, not number of nodes. That might be something that someone would get stuck on. If the tree is height-balanced, space complexity is O(logn) for the call stack.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Concept: 1) Use post-order traversal to update the max path running through each node after finding the max path of its subtrees.                                                                                                                                                                                                                                                              |
| Tree / Binary Tree                                    | E   | [](https://leetcode.com/problems/minimum-depth-of-binary-tree/description/)[111](https://leetcode.com/problems/minimum-depth-of-binary-tree/description/)                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC111-minimumDepthOfBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC111-minimumDepthOfBinaryTree.py)                                               | Minimum Depth of Binary Tree                           | O(N)            | O(H)             | There are many ways to solve this problem since we can track the minimum depth with a global variable or we can return the depth at each leaf and take the min of the left and right subtrees.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Use postorder traversal to find the minimum depth leaf of a binary tree.                                                                                                                                                                                                                                                                                                           |
| Tree                                                  | M   | [](https://leetcode.com/problems/flip-equivalent-binary-trees/)[951](https://leetcode.com/problems/flip-equivalent-binary-trees/)                                                                              |                                                                                                                                                                                                                                                  | Flip Equivalent Binary Trees                           |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Use post-order traversal to determine if the left and right subtrees of each node are flip equivalent and return this boolean to its caller.                                                                                                                                                                                                                                       |
| Tree                                                  | M   | [](https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/description/)[865](https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/description/)                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC865-smallestSubtreeWithAllTheDeepestNodes.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC865-smallestSubtreeWithAllTheDeepestNodes.py)                     | Smallest Subtree with all the Deepest Nodes            | O(N)            | O(H)             | Similar question to LC 1123 - "Lowest Common Ancestor of Deepest Leaves". Do a postorder traversal, getting the depth of the left and right subtrees. Then update the max depth using the current max depth, the left subtree depth and right subtree depth. If all of these are equal, then this is the root with the deepest nodes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Use post-order traversal to find the depth of each node's left and right subtrees recursively and update the answer if they are at the max depth seen so far.                                                                                                                                                                                                                      |
| Tree / Hash Map / DFS                                 | M   | [](https://leetcode.com/problems/most-frequent-subtree-sum/description/)[508](https://leetcode.com/problems/most-frequent-subtree-sum/description/)                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC508-mostfrequentSubtreeSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC508-mostfrequentSubtreeSum.py)                                                   | Most Frequent Subtree Sum                              | O(N)            | O(N)             | Get the frequency of each subtree sum as well as the max frequency using a DFS traversal and then return a list of all of the nodes whose subtree sums equal the max frequency.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Use post-order traversal to find the sum of each node's left and right subtrees and add these sums to the current node's value to get the current subtree sum.                                                                                                                                                                                                                     |
|                                                       |     |                                                                                                                                                                                                                |                                                                                                                                                                                                                                                  |                                                        |                 | Subpattern       | Level-order Traversal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                |
| Tree / Binary Tree / Breadth-First Search / Recursion | M   | [](https://leetcode.com/problems/binary-tree-level-order-traversal/)[102](https://leetcode.com/problems/binary-tree-level-order-traversal/)                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC102-binaryTreeLevelOrderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC102-binaryTreeLevelOrderTraversal.py)                                     | Binary Tree Level Order Traversal                      | O(N)            | O(N)             | This is a standard BFS traversal on a tree. If you are asked to do some type of processing of a tree structure level-wise, it will always be a BFS traversal. It is nearly identical in form to doing a BFS on a graph.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: Use level-order traversal to traverse a binary tree.                                                                                                                                                                                                                                                                                                                                  |
| Tree / N-ary Tree / Breadth-First Search / Recursion  | M   | [](https://leetcode.com/problems/n-ary-tree-level-order-traversal/description/)[429](https://leetcode.com/problems/n-ary-tree-level-order-traversal/description/)                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC429-n-aryTreeLevelOrderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC429-n-aryTreeLevelOrderTraversal.py)                                       | N-ary Tree Level Order Traversal                       | O(N)            | O(N)             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: Use level-order traversal to traverse an n-ary tree.                                                                                                                                                                                                                                                                                                                                  |
| Tree / Binary Tree / Breadth-First Search / Recursion | M   | [](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)[1161](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1161-maximumLevelSumOfBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1161-maximumLevelSumOfBinaryTree.py)                                       | Maximum Level Sum of a Binary Tree                     | O(N)            | O(N)             | Make sure the level_sum > max_level_sum check is > not >= because we want the minimum level. If we update based on if they are equal too, we are then taking the maximum level.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: Use level-order traversal to traverse a binary tree, tracking the sum of all node values of each level.                                                                                                                                                                                                                                                                               |
| Tree / BFS                                            | M   | [](https://leetcode.com/problems/find-largest-value-in-each-tree-row/)[515](https://leetcode.com/problems/find-largest-value-in-each-tree-row/)                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC515-findLargestValueInEachTreeRow.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC515-findLargestValueInEachTreeRow.py)                                     | Find the Largest Value in Each Tree Row                |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: Use level-order traversal to find the largest value of each level.                                                                                                                                                                                                                                                                                                                    |
| Tree / Binary Tree / BFS / DFS                        | M   | [](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)[103](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC103-binaryTreeZigzagLevelOrderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC103-binaryTreeZigzagLevelOrderTraversal.py)                         | Binary Tree Zigzag Level Order Traversal               | O(N)            | O(N)             | For BFS, we don't need a visited set if we are traversing a tree structure (no cycles, connected). As for problems with choices of BFS / DFS, try to implement them both. Also, make sure to do the recursive AND iterative approach to DFS problems. At least until you have a very strong ability to implement one or the other. This is because this is one of the most commonly asked follow-up questions. "Can you traverse this tree structure? Okay, now how about traversing it without recursion?"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: Use level-order traversal to traverse a binary tree in a zigzag pattern depending on the current level's depth.                                                                                                                                                                                                                                                                       |
| Tree                                                  | M   | [](https://leetcode.com/problems/minimum-height-trees/)[310](https://leetcode.com/problems/minimum-height-trees/)                                                                                              |                                                                                                                                                                                                                                                  | Minimum Height Trees                                   |                 |                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) BFS. 2) Minimum height tree. 3) There can be only 1 or 2 roots of a minimum height tree.                                                                                                                                                                                                                                                                                           |
| Tree / Binary Tree / Breadth-First Search             | M   | [](https://leetcode.com/problems/even-odd-tree/description/)[1609](https://leetcode.com/problems/even-odd-tree/description/)                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1609-evenOddTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1609-evenOddTree.py)                                                                       | Even Odd Tree                                          | O(N)            | O(N)             | This is a standard BFS problem on a tree. Maintain a level integer variable to track what level we are on. Use a prev variable to help check if the order is sorted according to its respective rule. Only check if a node is in its sorted order if it is the second node being checked, because there is no previous node to compare it to. So start the prev value at None, then we can use a condition where if prev is not None, check its relation to prev. Otherwise, just update prev.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: Use level-order traversal to traverse a binary tree, tracking the current level of the tree and checking if each node follows a constraint based on what level the node is in.                                                                                                                                                                                                        |
| Tree                                                  | M   | [](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)[116](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC116-populatingNextRightPointersInEachNode.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC116-populatingNextRightPointersInEachNode.py)                   | Populating Next Right Pointers in Each Node            | O(V+E)          | O(V)             | To assign next references, we just need to process the ndoes of the tree level-wise using BFS.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: Use level-order traversal to traverse a binary tree, updating the next pointer to the next node in the current level.                                                                                                                                                                                                                                                                 |
| Tree / DFS / BFS                                      | M   | [](https://leetcode.com/problems/deepest-leaves-sum/)[1302](https://leetcode.com/problems/deepest-leaves-sum/)                                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1302-deepestLeavesSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1302-deepestLeavesSum.py)                                                             | Deepest Leaves Sum                                     | O(N)            | O(H)             | The space complexity for the DFS approach is O(H) because this is the space for the call stack (O(N) for a skewed tree, O(H) for an average case where the tree is height-balanced). The call stack space for a tree does not exceed the height of the tree due to how DFS goes deep first and then returns. For BFS, it is O(N) space because in the worst case we will have N nodes in the queue for the last level. It isn't exactly N nodes because that would mean the entire tree is in the queue, which is impossible unless it is a single-node tree, but we say it is about N nodes when talking about Big O notation. As for which approach to learn and implement, you should be able to do both. DFS/BFS are arguably the two most important algorithms to know for interviews. And a very common follow-up question in interviews that involve DFS is "What if the tree is extremely tall and stack space is limited?" This is generally posed as a vague question to see if you understand space complexity tradeoffs between DFS and BFS, especially in an algorithm that is running on a tree data structure. Be confident with these algorithms, how to apply them and their tradeoffs. I would consider it a fundamental concept of DS&A. | Concept: Use level-order traversal to traverse a binary tree, getting the sum of the nodes' values on the deepest level.                                                                                                                                                                                                                                                                       |
