| Tree                                                                              |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| --------------------------------------------------------------------------------- | - | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Pre-order Traversal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | A common concept tested with pre-order algorithms is with root to leaf paths. The check at each root is "if not cur.left and not cur.right", meaning we are at a leaf.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Tree / Binary Tree / Depth-First Search / Recursion                               | E | [](https://leetcode.com/problems/binary-tree-preorder-traversal/)[144](https://leetcode.com/problems/binary-tree-preorder-traversal/)                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC144-binaryTreePreorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC144-binaryTreePreorderTraversal.py)                                                                             | Binary Tree Preorder Traversal                                              | Preorder traversal traverses the tree structure in this order: Root -> Left -> Right. One aspect of preorder/inorder/postorder traversal that might not be immediately obvious is we are processing subtrees in the same order as a parent-children subtree. So from the root we process the root and then the whole left subtree then the whole right subtree. And also at a leaf node we process the leaf, then the left child, then the right child. This understanding is important for many problems that require you to do/calculate something from each subtree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Use preorder traversal to print the nodes in a preorder fashion.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Tree / N-ary Tree / Depth-First Search / Recursion                                | E | [](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)[589](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)                                                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC589-N-aryTreePreorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC589-N-aryTreePreorderTraversal.py)                                                                               | N-ary Tree Preorder Traversal                                               | The space complexity is dependent on what someone considers to be extra space. Some people say data structures that store the output values are considered a part of the space complexity, while others don't. If the output array is counted, it is O(N) space copmlexity. If not, it is O(H) where H is the height of the tree (for the call stack). If an iterate BFS is done, it's always O(N) because the max size of the level in the BFS will have about N nodes in the queue. These tradeoffs are important to understand and should be able to be articulated in an interview.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Use pre-order traversal to traverse an n-ary tree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Tree / Binary Tree / Depth-First Search / Recursion                               | E | [](https://leetcode.com/problems/merge-two-binary-trees/)[617](https://leetcode.com/problems/merge-two-binary-trees/)                                                                                                                                    |                                                                                                                                                                                                                                                                                      | Merge Two Binary Trees                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Preorder traversal. 2) Traverse two trees at the same time in the same positions even if one tree does not have a node in this position.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Tree / Binary Tree / Depth-First Search / Recursion                               | E | [](https://leetcode.com/problems/same-tree/)[100](https://leetcode.com/problems/same-tree/)                                                                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC100-sameTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC100-sameTree.py)                                                                                                                   | Same Tree                                                                   | We might prefer the iterative DFS or BFS approach over the recursive DFS approach if stack space is an issue. Otherwise, the recursive DFS implementation Is way more clean and concise. If the tree is height-balanced, space complexity is O(logn) for the call stack of the DFS implementation. It is worth noting that I almost always omit iterative DFS solutions from explanations because the translation is trivial in most cases.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Use preorder traversal on two trees simultaneously, comparing the node values at each node. 2) Use boolean evaluation.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Tree / Binary Tree / Depth-First Search / Recursion                               | M | [](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)[1448](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)                                                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1448-countGoodNodesInBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1448-countGoodNodesInBinaryTree.py)                                                                             | Count Good Nodes in Binary Tree                                             | This is a standard DFS traversal problem of a tree with a subpattern of keeping track of a count outside of the nested function and returning nothing from the DFS. It is a preorder traversal because we process the current node, then dfs on left then dfs on right. Notice how path_max is passed by value, so each execution context gets its own copy of path_max.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Concept: 1) Use pre-order traversal to evaluate if the path to the current node has no nodes with a value greater than it.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Tree / Binary Tree / Depth-First Search                                           | E | [](https://leetcode.com/problems/binary-tree-paths/)[257](https://leetcode.com/problems/binary-tree-paths/)                                                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/binaryTreePaths.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/binaryTreePaths.py)                                                                                                                 | Binary Tree Paths                                                           | Cur_path is a list so in python it is passed by reference. This means that every execution context for each recursive call gets a reference to the same list. So when the call stack pops back up, we are still pointing ot the list that has that extra node in it. So we pop from cur_path to make sure each execution context has the corresponding path. The space complexity O(H) is for the call stack. If we consider the output array paths, then it would be closer to O(N\*H) since there can be about N paths of height H.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Use preorder traversal to print each root to leaf path. 2) Build the current path using a list parameter and preorder traversal (add to path first, then check if this node is a leaf). 3) Check if node is a leaf node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | In-order Traversal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Tree / Binary Tree / Depth-First Search / Recursion                               | E | [](https://leetcode.com/problems/binary-tree-inorder-traversal/)[94](https://leetcode.com/problems/binary-tree-inorder-traversal/)                                                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC94-binaryTreeInorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC94-binaryTreeInorderTraversal.py)                                                                                 | Binary Tree Inorder Traversal                                               | Inorder traversal traverses a tree structure in a Left -> Root -> Right sequence. The code might be hard to trace if you are not familiar with recursion. The visual of the code doesn't really reflect what is happening during program execution. I recommend watching a video that goes through the traversal if you are not able to visualize each step of the traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Use in-order traversal to print the nodes in an in-order fashion.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Tree / Binary Tree / Depth-First Search / Recursion                               | E | [](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)[783](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)                                                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC783-minimumDistanceBetweenBSTNodes.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC783-minimumDistanceBetweenBSTNodes.py)                                                                       | Minimum Distance Between BST Nodes                                          | The reason we do an inorder traversal is because the minimum difference between two nodes will always be between two nodes that are adjacent in sorted order. This similar to LC 285, but we are checking all successors, so a full inorder traversal is necessary. The reason we use a nonlocal variable outside of the dfs function is because the adjacent values aren't always directly connected by one edge, so we can't use something like a parent reference and must keep track of the last evaluated node. Think of how inorder works. Left -> Root -> Right. So it goes deep left, processes left, processes root, then processes right. The next value in the inorder traversal if there a more nodes in the tree is right's parent's parent, since right is in the left subtree of the Left -> Root -> Right traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Concept: 1) Use in-order traversal with a nonlocal variable tracking the previous node's value to find the minimum difference between two nodes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Tree / Binary Tree / Depth-First Search / Recursion                               | M | [](https://leetcode.com/problems/binary-search-tree-iterator/)[173](https://leetcode.com/problems/binary-search-tree-iterator/)                                                                                                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC173-binarySearchTreeIterator.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC173-binarySearchTreeIterator.py)                                                                                   | Binary Search Tree Iterator                                                 | To suspend the iterator on the next node, use a stack and populate it with all left nodes until we reach a null node. Then when next() is called, popping the node at the top of the stack will be the next node in the iterator. Then get the node's right reference (if it is not None) and again traverse down to the left, adding each node to the stack. This acts like inorder DFS where we suspend the iterator at the next node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Concept: 1) Use a stack to implement iterative in-order traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Post-order Traversal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Use when deleting nodes, evaluating expressions such as postfix notation in arithmetic expressions, or when performing calculations on children nodes/subtrees of current node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Tree / Binary Tree / Depth-First Search / Recursion                               | E | [](https://leetcode.com/problems/binary-tree-postorder-traversal/)[145](https://leetcode.com/problems/binary-tree-postorder-traversal/)                                                                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC145-binaryTreePostorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC145-binaryTreePostorderTraversal.py)                                                                           | Binary Tree Postorder Traversal                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use post-order traversal to print the nodes in a tree in a post-order fashion.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Tree / Binary Tree / Depth-First Search / Recursion                               | E | [](https://leetcode.com/problems/balanced-binary-tree/)[110](https://leetcode.com/problems/balanced-binary-tree/)                                                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC110-balancedBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC110-balancedBinaryTree.py)                                                                                               | Balanced Binary Tree                                                        | A somewhat tricky thing to come up with is returning a pair of values for each recursive call. Also note that this approach requires a helper function because isBalanced() returns a bool. So we can't use isBalanced() to pass the pair of values up the tree during recursion and eventually to the original caller which only wants a bool value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Use post-order traversal to compare subtree heights.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Tree / Binary Tree / Depth-First Search / Recursion                               | M | [](https://leetcode.com/problems/delete-leaves-with-a-given-value/description/)[1325](https://leetcode.com/problems/delete-leaves-with-a-given-value/description/)                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1325-deleteLeavesWithAGivenValue.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1325-deleteLeavesWithAGivenValue.py)                                                                           | Delete Leaves With a Given Value                                            | Use a postorder traversal. We want postorder so we can remove references of leaf nodes that match the target value starting from the bottom and going up. Since we are reassigning references, we can recursively set root.left and root.right to the respective DFS calls. And since we are assigning infromation to each child, we must return some information. And that infromation is the children nodes. So we encode the case that we want to delete by returning None, which will in turn set root.left or root.right to None if they should be deleted. Otherwise, we return root. And the base case returns None if root is None because we want root.left/root.right to be assigned to None if there is no node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Use post-order traversal to delete leaf nodes that match a target value. 2) Deleting a leaf node can make its parent a leaf node, making a bottom-up order beneficial.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Tree / Binary Tree / Depth-First Search / Recursion                               | M | [](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)[236](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)                                                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC236-lowestCommonAncestorOfABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC236-lowestCommonAncestorOfABinaryTree.py)                                                                 | Lowest Common Ancestor of a Binary Tree                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use post-order traversal to find the LCA of two nodes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Tree / Binary Tree / Depth-First Search / Recursion                               | M | [](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/)[2265](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/)                                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2265-countNodesEqualToAverageOfSubtree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2265-countNodesEqualToAverageOfSubtree.py)                                                               | Count Nodes Equal to Average of Subtree                                     | This is a problem that follows the subpattern of processing nodes in a postorder manner. We recurse deeply on the left, then on the right, store whatever information we get from the left and right subtrees into variables, and then use the left and right subtree values we found to compute what the problem is asking for. Important things to note for these types of problems: 1) We return a value in the recursion (a pair of values in this case) even in the base case. 2) We do a preorder traversal and store the values returned by the left and right subtrees in variables 'left' and 'right'. 3) We do a computation on the information we found in the two subtrees. 4) We return a value in the recursion to this execution context's caller (a pair of values in this case).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) use post-order traversal to find the average of the values of each node's left and right subtrees and compare it against the current node's value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Tree / Binary Tree / Depth-First Search / Recursion                               | H | [](https://leetcode.com/problems/binary-tree-maximum-path-sum/)[124](https://leetcode.com/problems/binary-tree-maximum-path-sum/)                                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC124-binaryTreeMaximumPathSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC124-binaryTreeMaximumPathSum.py)                                                                                   | Binary Tree Maximum Path Sum                                                | This is considered a postorder traversal because we traverse the left subtree, then right subtree, then we process the current. When returning in the DFS, we get max between cur, cur + left and cur + right because it's more explicit so it's easier to trace and understand, but the singular cur.val is not needed since negatives are changed to 0. If the tree is height-balanced, space complexity is O(logn) for the call stack.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Use post-order traversal to find the maximum path sum that goes through every node and its subtrees.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Level-order Traversal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Tree / Binary Tree / Breadth-First Search / Recursion                             | M | [](https://leetcode.com/problems/binary-tree-level-order-traversal/)[102](https://leetcode.com/problems/binary-tree-level-order-traversal/)                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC102-binaryTreeLevelOrderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC102-binaryTreeLevelOrderTraversal.py)                                                                         | Binary Tree Level Order Traversal                                           | This is a standard BFS traversal on a tree. If you are asked to do some type of processing of a tree structure level-wise, it will always be a BFS traversal. It is nearly identical in form to doing a BFS on a graph.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: Use level-order traversal to traverse a binary tree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Tree / N-ary Tree / Breadth-First Search / Recursion                              | M | [](https://leetcode.com/problems/n-ary-tree-level-order-traversal/description/)[429](https://leetcode.com/problems/n-ary-tree-level-order-traversal/description/)                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC429-n-aryTreeLevelOrderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC429-n-aryTreeLevelOrderTraversal.py)                                                                           | N-ary Tree Level Order Traversal                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: Use level-order traversal to traverse an n-ary tree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Tree / Binary Tree / Breadth-First Search / Recursion                             | M | [](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)[1161](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)                                                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1161-maximumLevelSumOfBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1161-maximumLevelSumOfBinaryTree.py)                                                                           | Maximum Level Sum of a Binary Tree                                          | Make sure the level_sum > max_level_sum check is > not >= because we want the minimum level. If we update based on if they are equal too, we are then taking the maximum level.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: Use level-order traversal to traverse a binary tree, tracking the sum of all node values of each level.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Vertical-order Traversal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Tree / Binary Tree / Hash Map / Depth-First Search / Recursion                    | H | [](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)[987](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC987-verticalOrderTraversalOfABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC987-verticalOrderTraversalOfABinaryTree.py)                                                             | Vertical Order Traversal of a Binary Tree                                   | The time complexity comes from the sorting of the columns and the rows when creating the result array that we return. A difficult part of the problem (at least for me) is traversing the dictionary to get the result. Not often are you required to sort keys in a dictionary, so not having this knowledge might push you to a different approach entirely which might be harder to implement. This is why knowing the data structures in your language and how to manipulate them is very important.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Concept: 1) Get the vertical ordering of a binary tree by using a column-to-row mapping. Similar to LC 314.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Binary Search Tree                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Tree / Binary Search Tree / Depth-First Search / Recursion                        | E | [](https://leetcode.com/problems/search-in-a-binary-search-tree/)[700](https://leetcode.com/problems/search-in-a-binary-search-tree/)                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC700-searchInABinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC700-searchInABinarySearchTree.py)                                                                                 | Search in a Binary Search Tree                                              | For time complexity, it is O(log(N)) if the tree is height-balanced and O(N) if it is not. Using the iterative traversal uses O(1) space because we do not need stack space for the function calls. As for recursion, the worst-case would be if the value we are looking for is a leaf node. No matter what, this scenario would yield a space complexity of O(H) due to the stack frames needed for each function call.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Use binary search to find a target value in a binary search tree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Tree / Binary Search Tree / Depth-First Search / Recursion                        | M | [](https://leetcode.com/problems/validate-binary-search-tree/)[98](https://leetcode.com/problems/validate-binary-search-tree/)                                                                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC98-validateBinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC98-validateBinarySearchTree.py)                                                                                     | Validate Binary Search Tree                                                 | All we have to do is keep a running minimum and maximum bound for each recursive call in the DFS as parameters, update them accordingly and check cur.val against them. To evaluate the boolean value of all subtrees, we need evaluate the left and right subtrees at each root. This is a very common subpattern of preorder traversal where we have a base case that returns a result and another case that acts as the processing part for the preorder traversal before dfs on left and right are called. Then we return left AND right, so True is only returned if all subtrees evaluate to True.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Concept: 1) Use preorder traversal to check if each node in a binary search tree is valid. 2) Use boolean evaluation for the return statement.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Tree / Binary Search Tree / Depth-First Search / Recursion                        | M | [](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)[235](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC235-lowestCommonAncestorOfABinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC235-lowestCommonAncestorOfABinarySearchTree.py)                                                     | Lowest Common Ancestor of a Binary Search Tree                              | Different from finding LCA of a tree that does not have the BST property because we know the upper bound of values in the left subtree and the lower bound of values in the right subtree at each root node of each subtree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Concept: 1) Use the BST property to check what subtree a target value is in relation to the current value. 2) Lowest common ancestor.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Tree / Binary Search Tree / Depth-First Search / Recursion                        | M | [](https://leetcode.com/problems/insert-into-a-binary-search-tree/)[701](https://leetcode.com/problems/insert-into-a-binary-search-tree/)                                                                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC701-insertIntoABinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC701-insertIntoABinarySearchTree.py)                                                                             | Insert into a Binary Search Tree                                            | The idea for this algorithm is to greedily search for an insert position at a position at the bottom of the tree that will make it a leaf. For the recursive function, there is no need to return anything because we are just updating a reference. For the iterative approach, we can iterate while True because we are guaranteed to reach a leaf node. Both approaches greedily converge to an insert position and look ahead to see if the reference in the correct direction is None.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Use binary search to search for an insert position and insert a new node with a given value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Tree / Binary Search Tree / Depth-First Search / Recursion                        | M | [](https://leetcode.com/problems/convert-bst-to-greater-tree/)[538](https://leetcode.com/problems/convert-bst-to-greater-tree/)                                                                                                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC538-convertBSTToGreaterTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC538-convertBSTToGreaterTree.py)                                                                                     | Convert BST to Greater Tree                                                 | This traversal is considered to be reverse inorder traversal. Inorder traversal is Left -> Root -> Right. Reverse inorder is Right -> Root -> Left. To explain why inorder and why reverse: The reason we do inorder traversal because inorder traversal of a BST processes each node in order from smallest to largest. (Keep in mind this is for a BST specifically). And the reason we do it in reverse order is because we want to process the nodes in order from largest to smallest according to the problem statement.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Use reverse in-order traversal to add the postfix sum of the sorted values to each node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Construct Tree                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Tree / Binary Tree / Depth-First Search / Recursion                       | E | [](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)[108](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)                                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC108-convertSortedArrayToBST.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC108-convertSortedArrayToBST.py)                                                                                     | Convert Sorted Array to BST                                                 | We have to use the sorted property of the array along with the relationship between values in a binary search tree to solve the problem. For the root of every subtree in a binary search tree, all of the values in the left subtree are less than the root, while all of the values in the right subtree are greater than the root. Since we want a height-balanced tree, we want the left and right subtrees to be of similar height. So we pick the root to be the middle of the array. Then we set the left child and right child of this root as the middle of the left subarray and right subarray respectively. We will do this recursively. The base case is when nums is empty, we return None.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Convert a sorted array to a binary search tree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Array / Tree / Binary Tree / Depth-First Search / Recursion                       | M | [](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)[105](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC105-constructBinaryTreeFromPreorderAndInorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC105-constructBinaryTreeFromPreorderAndInorderTraversal.py)                               | Construct Binary Tree from Preorder and Inorder Traversal                   | More explanation: The global 'preorder_index' is helpful because the preorder value is always the next value in the preorder array after a root is created. Root.left and root.right is fairly trivial now since we are only changing the bound respective to its side and we do not include the root value in each bound.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Convert a pre-order array and an in-order array into a binary tree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Tree / Binary Tree / Depth-First Search / Recursion                               | H | [](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)[297](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)                                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC297-serializeAndDeserializeBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC297-serializeAndDeserializeBinaryTree.py)                                                                 | Serialize and Deserialize Binary Tree                                       | There are two main ways these functions can be implemented. With DFS and with BFS. I prefer BFS because I think it is way easier to visualize the construction of a tree through BFS. Serialize matches the type of BFS you normally see because it is being done on a tree structure, whereas deserialize is doing BFS on a string. In deserialize it really is just a matter of understanding how to traverse the array to create the nodes and update the references to left and right of each root node. I strongly recommend watching Striver's video (the first 7 minutes) to get a good visualization on how this translation between a tree structure and string is done.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) Serialize and deserialize a binary tree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Binary Tree Indices                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Nodes can be described with an index of its level-order traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Tree / Binary Tree / Hash Set / Depth-First Search / Recursion                    | M | [](https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/description/)[1261](https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/description/)                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1261-findElementsInAContaminatedBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1261-findElementsInAContaminatedBinaryTree.py)                                           | Find Elements in a Contaminated Binary Tree                                 | This is similar to problems where you need the index of a node in a tree. One of these other problems is LC 662 - "Maximum Width of Binary Tree". So once we notice that the values of each node in this problem are actually the indices, you just need to know the formulas for calculating them and then this problem becuase fairly trivial. The formulas for each index: Left child = cur val \* 2 + 1. Right child = cur val \* 2 + 2. These indices can be found either with BFS or DFS. Both implementations use a "self.values" set to store visited indices of nodes, which is important to make the find() function an O(1) lookup.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Binary tree indices.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Tree / Binary Tree / Depth-First Search / Recursion                               | M | [](https://leetcode.com/problems/check-completeness-of-a-binary-tree/description/)[958](https://leetcode.com/problems/check-completeness-of-a-binary-tree/description/)                                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC958-checkCompletenessOfABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC958-checkCompletenessOfABinaryTree.py)                                                                       | Check Completeness of a Binary Tree                                         | A helpful trick you can use with binary trees is to calculate the index of each node from top to bottom and left to right. To calculate the node's index in the tree, start the root node at index 0. Then when we call dfs on the children, the left child's index is 2\*i+1, while the right child's index is 2\*i+2. We can use these indices to check if the last node we saw on the last level is equal to the number of nodes seen - 1. To have access to the last node's index in the last level of the tree, update it when we are at the max height/depth of the tree so far. Since dfs traverses the tree left to right, this is guaranteed to be the rightmost node in the last level of the tree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Binary tree indices. 2) Complete binary tree definition.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Build Graph                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Convert (or transition logic) a tree data structure into a graph data structure when the tree needs to be traversed like a graph (efficient access to all adjacent nodes).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Tree / Binary Tree / Graph / Breadth-First Search                                 | M | [](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)[863](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)                                                                                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC863-allNodesDistanceKInBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC863-allNodesDistanceKInBinaryTree.py)                                                                         | All Nodes Distance K in Binary Tree                                         | We need a visited hash set in the BFS because we have undirected edges in the new adjacency list. This is an important distinction between trees (no cycles) and undirected graphs (cycles). For populating the adjacency list, DFS is simpler and a better average time complexity (if tree is height-balanced because space complexity is O(log(N)) for the call stack instead of O(N) that the queue in BFS uses). For creating adj list with DFS, use cur and parent parameters and add undirected edge to adjacency list if cur and parent are not None. One thing to think about is how this way avoids duplicate edges. Imagine if you made an entry for left and right child at each DFS call.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Convert tree to graph. 2) Use breadth-first search to find distance to target value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Tree / N-ary Tree / Graph / Depth-First Search / Breadth-First Search / Recursion | M | [](https://leetcode.com/problems/reachable-nodes-with-restrictions/description/)[2368](https://leetcode.com/problems/reachable-nodes-with-restrictions/description/)                                                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2368-reachableNodesWithRestrictions.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2368-reachableNodesWithRestrictions.py)                                                                     | Reachable Nodes With Restrictions                                           | This is a standard DFS/BFS problem with a few extra complexities. The first complexity is checking if a node is restricted or not so we avoid going down this path. To do this efficiently, cast restricted to a set so we can do O(1) lookups for node values. The second complexity is the edges being undirected. Most tree problems provide a tree data structure with ListNodes that have directed edges (left and right typically), so you can only traverse the tree in one direction. But for this problem, we are only provided edges, and these edges are undirected. So when we start from 0 and go down the tree, we have to make sure we aren't going back up the tree and recounting nodes/going into an infinite loop. To avoid this, just use a prev reference for the parent node and make sure the neighbor node we are about to call DFS on isn't the parent of the current node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Concept: 1) Convert tree to graph. 2) Using prev to avoid traversing already traversed nodes, while also avoiding traversing nodes that are restricted. 3) Know how to do this for DFS and BFS (use prev parameter in DFS method signature and use tuples of (cur, prev) as nodes in queue).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Node Relationships                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Tree / Binary Tree / Breadth-First Search / Recursion                             | E | [](https://leetcode.com/problems/cousins-in-binary-tree/description/)[993](https://leetcode.com/problems/cousins-in-binary-tree/description/)                                                                                                            |                                                                                                                                                                                                                                                                                      | Cousins in Binary Tree                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Cousins in a binary tree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Tree / Binary Tree / Breadth-First Search / Recursion                             | M | [](https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/)[1315](https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/)                                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1315-sumOfNodesWithEven-ValuedGrandparent.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1315-sumOfNodesWithEven-ValuedGrandparent.py)                                                         | Sum of Nodes with Even-Valued Grandparent                                   | This implementation is an improvement on the slightly naïve approach of storing a path array that holds state that describes each node as either even or odd. But this adds an extra O(H) space complexity. For a constant O(1) space complexity, we keep two variables 'parent' and 'grand' to keep track of the even/odd bool for each node's ancestors. A mistake I initially made is trying to update grand to parent before checking 'if grand' in the recursive procedure. We want update grand after 'if grand' because the code assumes parent and grand are already updated before this check.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Grandparents in a binary tree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Backtracking                                                                      |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Permutations                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Generally follows pattern where you iterate over choice positions at each iteration, and for each position iterate over each choice. At each position, choose to pick or skip.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Array / Depth-First Search / Backtracking / Recursion                             | M | [](https://leetcode.com/problems/permutations/)[46](https://leetcode.com/problems/permutations/)                                                                                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC46-permutations.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC46-permutations.py)                                                                                             | Permutations                                                                | Order matters with permutations, whereas order does NOT matter with combinations. This is significant because we then have to make sure every ordering is expressed. To do so, we use an array that encodes whether an element in the input collection has been used or not. The for loop inside of each recursive call tries every position for every element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Generate a list of all the permutations of a given list of numbers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Depth-First Search / Backtracking / Recursion                                     | M | [](https://leetcode.com/problems/beautiful-arrangement/)[526](https://leetcode.com/problems/beautiful-arrangement/)                                                                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC526-beautifulArrangement.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC526-beautifulArrangement.py)                                                                           | Beautiful Arrangement                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Count all of the unique permutations that can be made in a range of numbers that follows a constraint. 2) Implicit collection of elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| String/ Depth-First Search / Backtracking / Recursion                             | M | [](https://leetcode.com/problems/letter-case-permutation/)[784](https://leetcode.com/problems/letter-case-permutation/)                                                                                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC784-letterCasePermutation.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC784-letterCasePermutation.py)                                                                         | Letter Case Permutation                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Generate all permuations of letter cases in a string. 2) Append number or recurse on choice to use lower case and recurse on choice to use upper case.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Matrix                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Matrix / Hash Set / Depth-First Search / Backtracking / Recursion                 | H | [](https://leetcode.com/problems/n-queens/)[51](https://leetcode.com/problems/n-queens/)                                                                                                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC51-N-Queens.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC51-N-Queens.py)                                                                                                     | N-Queens                                                                    | Base case: if r == n, append the board to the result array. Choice: Iterate for col in the range of the number of rows. If the column passes the valid state check, add it to the state. Otherwise, skip this entire if block (prune res of decision tree). Recursive procedure: backtrack(r + 1).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Generate all permutations of element placements in a 2D matrix that adheres to the constraints.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Backtracking                                                                      | H | [](https://leetcode.com/problems/sudoku-solver/)[37](https://leetcode.com/problems/sudoku-solver/)                                                                                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC37-sudokuSolver.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC37-sudokuSolver.py)                                                                                             | Sudoku Solver                                                               | Base case: if r == 9, return True. Constraints: Value in current cell must be unique for its respective row/col/square set and be in the range [1, 9]. Choice: If cell == '.', choose between the values [1, 9] to put in this cell. Pay attention to where the valid state checking is at. For this problem, it is inside the for loop. For word search, it is at the base case. We put it inside the for loop because it is the necessary placement for the execution flow. Why? Because the beginning of the for loop is the entry point for the changing state. This is the first part of the algorithm that sees this new value. The discrepency comes from carrying the state change as a method parameter vs generating it in a for loop. Check if choice meets constraints BEFORE recursing because you can't backtrack from a choice where you add the same number to a set since the set only encodes 1 number and cleaning up this decision by removing it wouldn't work as intended.(Hash map is a workaround, but general idea is to consider checking constraints before recursing).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Generate a permutations of elements in a 2D matrix that adheres to the constraints. 2) If using a set to track choices, check constraint before making the choice since you can't backtrack from the choice of adding a duplicate number to the set.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Combinations                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Generally follows pick/not pick pattern for each choice. Position does NOT matter. Ultimately: think of combination problems as where the choice in the sequence of choices is made doesn't matter.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| String / Hash Map / Depth-First Search / Backtracking / Recursion                 | M | [](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)[17](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)                                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC17-letterCombinationsOfAPhoneNumber.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC17-letterCombinationsOfAPhoneNumber.py)                                                     | Letter Combinations of Phone #                                              | We are asked to get every possible letter combination given digits. Since there is no way to avoid enumerating every possible combination, we can think of this problem as exploring all possible states, which tells us we need to use recursion. Our state is described as the index we are at in the digits string as well as the current combination we have built up. Reaching i == len(digits) signifies we have reached a solution state. The index is the only part of our state that can break the problem constraints (by going beyond the last digit in digits). So we don't need any other valid state checking beyond the base case for appending to res. As for our choices, the for loop handles this. For the backtrack, we just need to pop from combo.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Concept: 1) Generate all combinations of letters that can be produced from a phone number. 2) Use a hash map to map numbers to letters so each number's possible choices can be iterated over.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Array / Depth-First Search / Backtracking / Recursion                             | M | [](https://leetcode.com/problems/combinations/)[77](https://leetcode.com/problems/combinations/)                                                                                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC77-combinations.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC77-combinations.py)                                                                                             | Combinations                                                                | This is similar to LC 78 - "Subsets" except we want combinations of size k and in the range [1, n].                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Generate all combinations with the constraints of combination size and numbers within a range.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Array / Depth-First Search / Backtracking / Recursion                             | M | [](https://leetcode.com/problems/combination-sum/)[39](https://leetcode.com/problems/combination-sum/)                                                                                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC39-combinationSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC39-combinationSum.py)                                                                                         | Combination Sum                                                             | Our time complexity O(2^N\*N) because we are bounded by N instead of T since we can pick at most N elements if we have an element equal to 1 in the input candidates. The extra N is for copying the combination list we are building up to add it to the output list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Generate all combinations with the constraints of a target combination sum and possible choices being a list of candidates.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Array / String / Hash Map / Depth-First Search / Backtracking / Recursion         | H | [](https://leetcode.com/problems/maximum-score-words-formed-by-letters/description/)[1255](https://leetcode.com/problems/maximum-score-words-formed-by-letters/description/)                                                                             |                                                                                                                                                                                                                                                                                      | Maximum Score Words Formed by Letters                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Generate a combination of words that has a maximum score. 2) Track and backtrack choices using a count hash map for each used character.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Array / Depth-First Search / Backtracking / Recursion                             | M | [](https://leetcode.com/problems/fair-distribution-of-cookies/)[2305](https://leetcode.com/problems/fair-distribution-of-cookies/)                                                                                                                       |                                                                                                                                                                                                                                                                                      | Fair Distribution of Cookies                                                | Each choice has the potential to put into k buckets. The reason we can't do partition backtracking is because the partitions don't have to be in order. So we instead opt to iterate over the buckets (children) to make a choice to put the current in one of the k buckets.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Bucket backtracking.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Array / Depth-First Search / Backtracking / Recursion                             | M | [](https://leetcode.com/problems/matchsticks-to-square/)[473](https://leetcode.com/problems/matchsticks-to-square/)                                                                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC473-matchsticksToSquare.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC473-matchsticksToSquare.py)                                                                             | Matchsticks to Square                                                       | In problems like Sudoku Solver, we are recursing through the input collection (board) and iterating through the choice spcae (numbers 1-10). For this problem, it is slightly different. We are recursing through the input collection (matchsticks array) and iterating through the choice space (position in the state collection). The key thing to understand for this problem is we are essentially trying to find the correct combination of matchsticks for each side (bucket) of the square.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Concept: 1) Determine if an array partitioned into buckets where each bucket adheres to a constraint.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Partition Sequence                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Partition a collection of given elements into a sequence. FOLLOW THIS CONCEPT DESCRIPTION FORMAT.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| String / Hash Set / Depth-First Search / Backtracking / Recursion                 | M | [](https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/description/)[1593](https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/description/)                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC1593-splitAStringIntoTheMaxNumberOfUniqueSubstrings.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC1593-splitAStringIntoTheMaxNumberOfUniqueSubstrings.py)                     | Split a String Into the Max Number of Unique Substrings                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Generate all partitions of a string that adhere to constraints.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| String / Depth-First Search / Backtracking / Recursion                            | M | [](https://leetcode.com/problems/palindrome-partitioning/)[131](https://leetcode.com/problems/palindrome-partitioning/)                                                                                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC131-palindromePartitioning.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC131-palindromePartitioning.py)                                                                       | Palindrome Partitioning                                                     | This is similar to Restore IP Addresses in that this is a substring backtracking problem. We want to partition the array into different substrings that adhere to the constraints.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Generate all partitions of a string that adhere to constraints. 2) Check if a substring is a palindrome.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| String / Hash Set / Depth-First Search / Backtracking / Recursion                 | H | [](https://leetcode.com/problems/word-break-ii/description/)[140](https://leetcode.com/problems/word-break-ii/description/)                                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC140-wordBreakII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC140-wordBreakII.py)                                                                                             | Word Break II                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Generate all partitions of a string that adhere to constraints.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Generate Sequence                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Generate a sequence of elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Depth-First Search / Backtracking / Recursion                                     | M | [](https://leetcode.com/problems/numbers-with-same-consecutive-differences/description/)[967](https://leetcode.com/problems/numbers-with-same-consecutive-differences/description/)                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC967-numbersWithSameConsecutiveDifferences.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC967-numbersWithSameConsecutiveDifferences.py)                                         | Numbers With Same Consecutive Differences                                   | There are a lot of people who classify their solutions as DFS or use BFS of some kind, but this problem is designed for backtracking (yes, DFS and backtracking are often used interchangeably for problems that explore all possibilities). I think my solution is by far the easiest to use for most other backtracking problems since it fits my backtracking template.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Generate all sequences that adhere to constraints.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Subsets                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Similar to combinations, but include all sizes of combinations of unique elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Array / Depth-First Search / Backtracking / Recursion                             | M | [](https://leetcode.com/problems/subsets/)[78](https://leetcode.com/problems/subsets/)                                                                                                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC78-subsets.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC78-subsets.py)                                                                                                       | Subsets                                                                     | For subsets, order does not matter. So [1, 2] is considered to be the same as [2, 1]. This is considered to be a problem that a brute-force approach cannot be avoided because we have to generate all subsets. There is no way to shortcut the generation of 2^N subsets. Why is there 2^N subsets for a list of unique elements? Because at every index, we can choose to 1) include the element or 2) skip the element. This is two choices at each index. So 2^N possible choices. If the output array is considered as a part of the space comlexity, it is O(2^N^2).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Generate all subsets of a given list of numbers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Array / Depth-First Search / Backtracking / Recursion                             | M | [](https://leetcode.com/problems/subsets-ii/)[90](https://leetcode.com/problems/subsets-ii/)                                                                                                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC90-subsetsII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC90-subsetsII.py)                                                                                                   | Subsets II                                                                  | This is similar to LC 78 - "Subsets" with one difference: there can be duplicate values in the input array nums. So it isn't sufficient to just do the same approach as in LC 78. If we have an input array of [1, 2, 2], the previous approach will add duplicate subsets such as [1, 2] and [1, 2] because we can pick either of the two 2's. To avoid duplicates, we must adjust our pick/not pick logic. If we pick an element, we can pick that element's value again in the future for this path. But if we skip it, we must skip all future elements equal to this value. To help with this, we sort the input array nums. Order doesn't matter. Pick or don't pick. If not picking element, skip all instances of this element. Sort at beginning.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Generate all unique subsets of a given list of numbers that may contain duplicates. 2) Presorting to make a decision based on adjacent numbers in sorted order.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Search                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Search for some goal state and if current path does not match constraints, backtrack.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Matrix / Hash Set / Depth-First Search / Backtracking / Recursion                 | M | [](https://leetcode.com/problems/word-search/)[79](https://leetcode.com/problems/word-search/)                                                                                                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC79-wordSearch.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC79-wordSearch.py)                                                                                                 | Word Search                                                                 | Base cases: If we reach end of word or the current (r, c) cell is not valid. Constraints: Char in the current cell must match the current index of the word. Choice: Go up, down, left or right from the current cell if the current cell's char matches the current index of the word. For the time complexity: it is 3^L where L is the length of the word because we won't recurse on a visited cell, so that leaves us with at most 3 options in direciton.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Search for a sequence of elements in a 2D matrix.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Matrix / Hash Set / Depth-First Search / Backtracking / Recursion                 | H | [](https://leetcode.com/problems/unique-paths-iii/description/)[980](https://leetcode.com/problems/unique-paths-iii/description/)                                                                                                                        | Code                                                                                                                                                                                                                                                                                 | Unique Paths III                                                            | The is a "number of ways" recursion subpattern. For the base cases, if the condition is not met, we return 0. If it is met, we return 1. Then for the recursive procedure we have the paths variable starting at 0 and add to it the return value of each dfs call. Make sure we add to cur_vis before calling dfs on this cell, then remove from cur_vis when the calls return and return the paths array to its parent calls.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Number of ways to arrive at a destination with up, down, left and right moves. 2) Matrix search backtracking.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Binary Search                                                                     |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Element Search                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Search for existence of explicit element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Array / Binary Search / Two Pointers                                              | E | [](https://leetcode.com/problems/binary-search/)[704](https://leetcode.com/problems/binary-search/)                                                                                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC704-binarySearch.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC704-binarySearch.py)                                                                                     | Binary Search                                                               | This is the target subpattern because we are looking for a specific element to see if it exists in the array or not. So we can do a standard binary search while left <= right and updating the search space based on what the element's value is at our pivot index mid in comparison to our target value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Use binary search to find an explicit value in a sorted collection of elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Binary Search / Two Pointers                                                      | E | [](https://leetcode.com/problems/guess-number-higher-or-lower/)[374](https://leetcode.com/problems/guess-number-higher-or-lower/)                                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC374-guessNumberHigherOrLower.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC374-guessNumberHigherOrLower.py)                                                             | Guess Number Higher or Lower                                                | This is a standard binary search for a target number with the slight added complexity of using an API to determine the mid's relation to the target. The Target/Contains subpattern either finds the target and returns or updates the search space based on the target.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Concept: 1) Use binary search to find an explicit value in a sorted implicit collection of elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Matrix / Binary Search / Two Pointers                                             | M | [](https://leetcode.com/problems/search-a-2d-matrix/)[74](https://leetcode.com/problems/search-a-2d-matrix/)                                                                                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC704-binarySearch.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC704-binarySearch.py)                                                                                     | Search a 2D Matrix                                                          | This is a target subpattern because we are looking for a specific element to see if it exists in the 2D matrix or not. We first look for the row using top and bottom pointers (break when found since we can't return early unless this is in its own function). To get the row we can do the mid calculation again, or we can store the mid in a variable outside of the while loop. Then from the second binary search on the row, we use left and right pointers to get the column and return True if the element is found or False if the while loop terminates without finding the element. We don't need to have an overflow-friendly mid calculation because of the constraints of m and n in this problem, but this should always be discussed in an interview.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Concept: 1) Use binary search to find an explicit value in a sorted collection of elements in a 2D matrix.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Array / Binary Search / Two Pointers                                              | M | [](https://leetcode.com/problems/search-in-rotated-sorted-array/)[33](https://leetcode.com/problems/search-in-rotated-sorted-array/)                                                                                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC33-searchInRotatedSortedArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC33-searchInRotatedSortedArray.py)                                                           | Search in Rotated Sorted Array                                              | The first thing that should come to mind when hearing search in a sorted array is binary search. But, we have added complexity with the array being rotated. The binary search can be augmented by first checking which sorted portion of the array our pivot value 'mid' is in. To do this, we do the 'if nums[left] <= nums[mid]' check. Then we check target against nums[mid] and the left/right boundary depending on what sorted portion we determined we were in at the last step. If the left pointer crosses the right pointer without us finding the target, we can return -1. This is the same as returning T/F if the number can be found or not, which is why this is considered to be the "contains" subpattern for binary search.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Use binary search to find an explicit value in a sorted collection of elements that is rotated.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Array / Binary Search / Two Pointers                                              | M | [](https://leetcode.com/problems/find-peak-element/)[162](https://leetcode.com/problems/find-peak-element/)                                                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC162-findPeakElement.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC162-findPeakElement.py)                                                                               | Find Peak Element                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use binary search to find a value with a specific relation to its adjacent values.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Array / Binary Search / Two Pointers                                              | M | [](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)[34](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC34-findFirstAndLastPositionOfElementInSortedArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC34-findFirstAndLastPositionOfElementInSortedArray.py)                   | Find First and Last Position of Element in Sorted Array                     | Both templates are appropriate for this problem, but the first template is a bit easier to implement because template 2 requires more edge case handling.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: Use binary search to find the leftmost and rightmost instances of a target value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Condition Search                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Search for first occurrence of a condition. Make sure each concept includes the parenthesis that explains the generic explanation for the specific problem). I did this for LC 2300's concept, for example.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Array / Binary Search / Two Pointers                                              | E | [](https://leetcode.com/problems/search-insert-position/)[35](https://leetcode.com/problems/search-insert-position/)                                                                                                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC35-searchInsertPosition.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC35-searchInsertPosition.py)                                                                       | Search Insert Position                                                      | Template 2: The True side starts at the first number that is greater than or equal to the target. The case where the target exists is obvious, but when the target doesn't exist, we want to insert it after the number below it and before the number higher than it. Since the insert position has to be AFTER the number lower than it, the case where nums[mid] > target, we use the right = mid statement.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use binary search to find the insert position of an element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Array / Binary Search / Two Pointers                                              | E | [](https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/description/)[2529](https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/description/)                                           |                                                                                                                                                                                                                                                                                      | Maximum Count of Positive Integer and Negative Integer                      | Make sure to start right index as len(nums) because there can be cases where the index that represents the start of the positive numbers doesn't exist, which would allow us to do len(nums) - right (which would be len(nums)) to calculate the number of positive numbres, which ends up being 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Use binaary search to find the ending position of the negative numbers and the starting position of the positive numbers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Array / Binary Search / Two Pointers / Prefix                                     | E | [](https://leetcode.com/problems/longest-subsequence-with-limited-sum/)[2389](https://leetcode.com/problems/longest-subsequence-with-limited-sum/)                                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC2389-longestSubsequenceWithLimitedSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC2389-longestSubsequenceWithLimitedSum.py)                                           | Longest Subsequence With Limited Sum                                        | We can sort the array and then we are able to greedily include elements in the sequence from left to right. This greedy approach guarantees the longest subsequence for the desired query sum because we are adding the least amount to the sum at each index starting from the left. It is the "less or equal" subpattern because we are updating our longest we have so far by changing the index if val < query. And in the case where val == query, we can break because it will be the longest subsequence.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Use binary search with prefix sums to find the first value that satisfies a condition (first prefix sum that is greater than queries[i]).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Array / Binary Search / Two Pointers                                              | M | [](https://leetcode.com/problems/peak-index-in-a-mountain-array/)[852](https://leetcode.com/problems/peak-index-in-a-mountain-array/)                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC852-peakIndexInAMountainArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC852-peakIndexInAMountainArray.py)                                                           | Peak Index in a Mountain Array                                              | To fit a binary search template, we can't use template 1 because there is no easy way to implement the logic where we make a decision to search to the left or right since we don't have a target value and the array isn't totally sorted. So we instead opt for template 2. With every problem in template 2, we force our thinking by starting on the right side being the True condition. The goal is to find the pair of values where two consecutive values go from increasing to decreasing. The middle value is the peak index. From the right, the True condition can be arr[mid] < arr[mid-1]. This means the final True will have arr[right] as arr[mid], which is the leftmost occurrence where arr[mid] < arr[mid-1].                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Use binary search to find the first element that satisfies a condition in an explicit collection of elements. 2) Compare current value to value to its left.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Array / Binary Search / Two Pointers                                              | M | [](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)[1011](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC1011-capacityToShipPackagesWithinDDays.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC1011-capacityToShipPackagesWithinDDays.py)                                         | Capacity To Ship Packages Within D Days                                     | This is like LC 875, Koko eating bananas problem. We are searching for the least value that satisfies a condition. It's a subset of binary search that is O(Nlog(N)) time complexity because we have to make a guess, do O(N) time computations, then decrease the search space by half. This is bisect left.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Use binary search to find the first element in an implicit collection of elements (weight capacity) that satisfies a constraint (number of days to ship all packages with "mid" weight is <= "days").                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Array / Binary Search / Two Pointers                                              | M | [](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)[153](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC153-findMinimumInRotatedSortedArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC153-findMinimumInRotatedSortedArray.py)                                               | Find Minimum in Rotated Sorted Array                                        | With rotated sorted array binary search, we have to identify if we are in the left sorted portion or right sorted portion at each iteration. Unlike LC 33 - "Search in a Rotated Sorted Array", this is the only thing we have to check in terms of adjusting our search space at each iteration. In LC 33 we also had to compare the target value against the number at mid and left, but in this problem we aren't looking for a target - just the minimum value. So it is sufficient to just check if nums[left] is less than or equal to nums[mid] to adjust our search space. However, there is one edge case that we have to consider. We can be in the right sorted portion where our left index holds the min value. In this case our nums[left] <= nums[mid] would incorrectly ignore it and update the search space to left = mid + 1. To avoid this, we set a check at the beginning of each iteration if nums[left] < nums[right].                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Use binary search to find the first element in a rotated sortedarray that is smaller or equal to the element to its right.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Misc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Binary Search / Two Pointers                                              | H | [](https://leetcode.com/problems/median-of-two-sorted-arrays/)[4](https://leetcode.com/problems/median-of-two-sorted-arrays/)                                                                                                                            |                                                                                                                                                                                                                                                                                      | Median of Two Sorted Arrays                                                 | Things to know: median of even length array is middle two elements / 2, while median of odd length array is middle element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Binary search two sorted collections of elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Heap                                                                              |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Greedy                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Greedily get max/min element in a sorted collection of elements repeatedly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Array / Heap / Hash Map / Greedy                                                  | M | [](https://leetcode.com/problems/distant-barcodes/description/)[1054](https://leetcode.com/problems/distant-barcodes/description/)                                                                                                                       |                                                                                                                                                                                                                                                                                      | Distant Barcodes                                                            | Very similar to LC 767: Reorganize String.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Use max heap to get element with maximum frequency element where the element counts are dynamically changing. 2) Get max frequency element at each step to minimize chance of needing to use same element twice in a row in the future. 3) Pop from heap twice if the current maximum frequency element is equal to the previous selected element to avoid equal adjacent elements.                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Heap / Greedy                                                             | M | [](https://leetcode.com/problems/minimum-operations-to-halve-array-sum/description/)[2208](https://leetcode.com/problems/minimum-operations-to-halve-array-sum/description/)                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC2208-minimumOperationsToHalveArraySum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC2208-minimumOperationsToHalveArraySum.py)                                                                 | Minimum Operations to Halve Array Sum                                       | Intuitively it makes sense that if we want to decrease a sum with the minimum number of operations, we pick the biggest numbers first. And that is what we do. Since we are picking numbers, altering them, and then adding them back into a sorted collection of elements, this follows the benefits of a heap.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Use a max heap to greedily retrieve the maximum value element to halve, which maximizes the depletion rate, thus minimizing the total number of operations.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Heap / Greedy                                                                     | M | [](https://leetcode.com/problems/maximum-score-from-removing-stones/description/)[1753](https://leetcode.com/problems/maximum-score-from-removing-stones/description/)                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1753-maximumScoreFromRemovingStones.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1753-maximumScoreFromRemovingStones.py)                                                                     | Maximum Score From Removing Stones                                          | This follows the common problem pattern where we are getting the min/max from a collection of elements, altering them, and then adding them back to the collection of elements multiple times. This problem pattern uses a heap data structure to do this efficiently.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Use a max heap to greedily retrieve the max element in a collection of elements to maximize the sum.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Kth Largest / Smallest                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Get the kth largest or smallest element                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Array / Heap                                                                      | M | [](https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/)[1985](https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/)                                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1985-findTheKthLargestIntegerInTheArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1985-findTheKthLargestIntegerInTheArray.py)                                                             | Find the Kth Largest Integer in the Array                                   | Important note: The wording for these problems can often be confusing. Kth largest means the kth element in a sorted collection of elements. For max heap, we heapify the entire array first so that the heap is in increasing to decreasing order. This means k pops will get our answer. For a min heap, we are making sure no more than k numbers are in the heap. After each push/pop, the kth + 1 largest element will be evicted from the heap. Max heap is O(KlogN + N) and min heap is O(NlogK). When K >= n/2, O(NlogK) will be better than O(KlogN + N).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Use a min heap of size k, popping from the heap when the size is k + 1. The next pop after the last integer is added is the Kth largest integer. 2) Heapify the given array to make it a max heap and the Kth pop is the Kth largest integer.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Matrix / Heap                                                                     | M | [](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)[378](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)                                                                                                  |                                                                                                                                                                                                                                                                                      | Kth Smallest Element in a Sorted Matrix                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use a max heap of size k, popping from the heap when the size is k + 1. The next pop after the last integer is added is the Kth smallest integer. 2) Heapify the given array to make it a min heap and the Kth pop is the Kth smallest integer.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | K Largest / Smallest                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Get the k largest/smallest elements. This is generally an approach used to improve nlogn sorting to nlogk where k is the number of largest/smallest elements we are looking for.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Array / String / Heap                                                             | E | [](https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/description/)[2099](https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/description/)                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC2099-findSubsequenceOfLengthKWithTheLargestSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC2099-findSubsequenceOfLengthKWithTheLargestSum.py)                                               | Find Subsequence of Length K With the Largest Sum                           | To find the subsequence, we need to find the k largest numbers in nums. To do this we could sort or use a min heap. Sorting is O(Nlog(N)) time, while using a min heap is O(Nlog(K)) time because we can pop from the min heap when the min heap length is > k (popping the smallest value), meaning pushing and popping is at most log(K) time and we do this N times. Then to recover the subsequence IN ORDER, we just need to get the counts of each value in the min heap, lienarly iterate through the nums array and when we see a num that is in the count hash map, add it to the result list and decrement the count of that value in the hash map.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Use a min heap of size K to get a collection of the K largest elements. 2) If subsequence sum is the only concern, the order of the elements in the subsequence does not matter.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Array / String / Hash Map / Heap                                                  | M | [](https://leetcode.com/problems/top-k-frequent-words/)[692](https://leetcode.com/problems/top-k-frequent-words/)                                                                                                                                        |                                                                                                                                                                                                                                                                                      | Top K Frequent Words                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) To get K most frequent, use counter and pop k most.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Min / Max Element                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Retrieve highest/lowest element repeatedly. Same as greedy strategy, but not categorized as a greedy algorithm because it's not considered the "best" choice at each decision, it's just what the choice of the problem description describes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Array / Heap                                                                      | E | [](https://leetcode.com/problems/last-stone-weight/)[1046](https://leetcode.com/problems/last-stone-weight/)                                                                                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1046-lastStoneWeight.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1046-lastStoneWeight.py)                                                                                                   | Last Stone Weight                                                           | We are deleting and adding to an sorted ordering of numbers. This follows the criteria for a problem pattern that tends to require a heap to solve it optimally. Getting the largest or smallest element repeatedly leans toward a heap solution.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) Use a max heap to retrieve the max two elements from a collection of elements repeatedly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Array / Hash Map / Heap                                                           | M | [](https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/description/)[1481](https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/description/)                                                       |                                                                                                                                                                                                                                                                                      | Least Number of Unique Integers after K Removals                            | Good greedy heap problem. Uses the pattern of counts hash map + heap.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Counts hash map. 2) Use a min heap to greedily retrieve the minimum count element to decrease.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Array / Heap                                                                      | M | [](https://leetcode.com/problems/single-threaded-cpu/)[1834](https://leetcode.com/problems/single-threaded-cpu/)                                                                                                                                         |                                                                                                                                                                                                                                                                                      | Single-Threaded CPU                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | K Lists                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Put all first elements in min heap. Merge k linked list, merge k sorted arrays etc. Each element has a (value, index, row number).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Linked List / Heap                                                                | H | [](https://leetcode.com/problems/merge-k-sorted-lists/)[23](https://leetcode.com/problems/merge-k-sorted-lists/)                                                                                                                                         |                                                                                                                                                                                                                                                                                      | Merge k Sorted Lists                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) K lists min heap.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Array / Heap                                                                      | H | [](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/)[632](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/)                                                                                      |                                                                                                                                                                                                                                                                                      | Smallest Range from K Lists                                                 | To get the minimum range, we can start by choosing the minimum of each list. The next step is to remove the minimum value between the k lists and consider its next element. Moving the minimum index to the right guarantees we are checking possible pairings that have the smallest range.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) K lists min heap.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Misc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Heap                                                                      | M | [](https://leetcode.com/problems/process-tasks-using-servers/)[1882](https://leetcode.com/problems/process-tasks-using-servers/)                                                                                                                         |                                                                                                                                                                                                                                                                                      | Process Tasks Using Servers                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Two heaps.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Heap                                                                              | H | [](https://leetcode.com/problems/find-median-from-data-stream/)[295](https://leetcode.com/problems/find-median-from-data-stream/)                                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC295-findMedianFromDataStream.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC295-findMedianFromDataStream.py)                                                                                   | Find Median from Data Stream                                                | Finding the median in an array of numbers is simple, but complexity is added if the array of numbers is instead a stream of numbers, and finding the median is a frequent operation. This is when we want to efficiently have access to the median of the array of values without having to traverse all N values. This is where the concept of using a min and max heap together to separate the stream of values into two parts and every time a number is added, work is done to maintain these halves.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Use min and max heap to find the median value in a data stream.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Counting Sort                                                                     |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      | 5                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Used over heap when the number of elements in the sorted collection of elements is predetermined and frequency of elements in sorted order is desired. Improves O(Nlog(K)) time complexity to O(N).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Greedy                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Use a frequency array to greedily pick the most/least frequent element at each step                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Array / Counting Sort                                                             | M | [](https://leetcode.com/problems/reduce-array-size-to-the-half/description/)[1338](https://leetcode.com/problems/reduce-array-size-to-the-half/description/)                                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1338-reduceArraySizeToTheHalf.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1338-reduceArraySizeToTheHalf.py)                                                                     | Reduce Array Size to The Half                                               | Use this as example to sort dictionaries based on value (frequency) using lambda.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) Use a frequency array to store the integers in sorted order based on their frequency and iterate through the frequency array from right to left to greedily decrease the array size by the most possible for each chocie.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | K Most / Least Frequent                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Get the k most frequent or least frequent elements in a collection of elements                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Matrix / Counting Sort                                                            | E | [](https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/)[1337](https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/)                                                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1337-theKWeakestRowsInAMatrix.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1337-theKWeakestRowsInAMatrix.py)                                                                                 | The K Weakest Rows in a Matrix                                              | Since problem asks for ordering of frequency ties to be from lower index to higher index, we can use counting sort. This is because ties will naturally be placed correctly if we iterate from the first to last row.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Use a frequency array to store the row weaknesses in sorted order and iterate through the frequency array starting from left to right to get the K weakest rows.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Sort by Frequency                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Similar to greedy, but instead it is simply explicitly want sorted frequencies.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| String / Counting Sort                                                            | E | [](https://leetcode.com/problems/increasing-decreasing-string/description/)[1370](https://leetcode.com/problems/increasing-decreasing-string/description/)                                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC1370-increasingDecreasingString.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC1370-increasingDecreasingString.py)                                                                         | Increasing Decreasing String                                                | We need to maintain some type of count for the characters we choose from, pick one character at each iteration, and make sure the next is greater than the previous from left to right and then the next smaller than the previous from right to left. This follows perfectly with what an array can provide us. But how do we do char -> array index mappings? Python's ord function. We can use an array of size 26 and 'a' corresponds to 0, 'b' corresponds to 1 etc. To do this char -> index mapping, we do 'char - ord('a')'. This gives us an integer from 0-26 for lowercase letters. Then when we want to get the char back from this index number, we do chr(i + ord('a')), which is essentially doing the reverse.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Convert character to ordinal value. 2) Counting sort using character ordinal values.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Array / Counting Sort                                                             | E | [](https://leetcode.com/problems/relative-sort-array/description/)[1122](https://leetcode.com/problems/relative-sort-array/description/)                                                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1122-relativeSortArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1122-relativeSortArray.py)                                                                                   | Relative Sort Array                                                         | Since we want to add to the result array the numbers seen in arr2 in order, we will linearly iterate through arr2. To find if the current number we are at in the arr2 traversal is in the arr1 efficiently, we use a set that contains the elements in arr1 for a quick O(1) lookup. Then when we find out this number in arr2 is also a number in arr1, we need the frequency of it in arr1. To do this, we first find the frequency of all numbers. Here we have to make a decision of using a hash map or array to encode the frequencies. Since we need to add elements that are not seen in arr2 in ASCENDING order, we choose to use an array as the indices of an array that encode the element number are naturally in ascending order. Also, when we are adding all the elements that are both in arr2 and arr1 to res, we can change the frequency in the array to 0. That way when we do the part of the algorithm where we have to add the remaining elements in ascending order, we just append the elements that have a frequency greater than 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Use a frequency array to store the frequency of each element where the array index represent the integer and the value at that index represents the frequency. 2) Use the frequency array to avoid sorting time complexity when needing to retrieve values in sorted order.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| String / Hash Map / Counting Sort                                                 | M | [](https://leetcode.com/problems/sort-characters-by-frequency/)[451](https://leetcode.com/problems/sort-characters-by-frequency/)                                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC451-sortCharactersByFrequency.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC451-sortCharactersByFrequency.py)                                                                             | Sort Characters by Frequency                                                | This is a bucket sort problem and very similar to LC 347 - "Top K Frequent Elements". The brute-force approach is to either get the frequencies via a Counter and sort based on frequencies or create a max heap of the chars based on their frequencies and getting the max element from the max heap until it is empty. This is O(Nlog(N)) time. But we can solve this problem in O(N) time by doing bucket sort. We have len(s) + 1 arrays inside of a frequency array. Each indexed array represents a frequency seen and the elements inside the array are the chars at that frequency. Iterating from the back of the frequency list to the front gets the most frequent to least frequent chars.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Use a frequency array to store the characters in sorted order based on their frequency and iterate through the frequency array from right to left to build up the sorted string based on frequency.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Linked List                                                                       |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      | 25                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Trivial Pointer Ops                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Linked List                                                                       | E | [](https://leetcode.com/problems/merge-two-sorted-lists/)[21](https://leetcode.com/problems/merge-two-sorted-lists/)                                                                                                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC21-mergeTwoSortedLists.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC21-mergeTwoSortedLists.py)                                                                             | Merge Two Sorted Lists                                                      | One thing that people misunderstand about pointer manipulation problems is they think that these are linear time algorithms. But it must be understood that the new memory being allocated is only for a singular dummy node and a reference to that dummy node. Everything else is just shifting pointers around. If you think of a list node in memory, it has a space for data to store a reference to the next node. We are just updating this data to different data. We aren't adding any new data.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: Merge two sorted linked lists into a single sorted linked list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Linked List / Math                                                                | M | [](https://leetcode.com/problems/add-two-numbers/)[2](https://leetcode.com/problems/add-two-numbers/)                                                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC2%20-%20addTwoNumbers.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC2%20-%20addTwoNumbers.py)                                                                               | Add Two Numbers                                                             | To add two numbers in base 10, we use a carry and add the two digits along with the carry together. The new carry is this place's sum divided by 10 and the digit is this place's sum modulo 10. We iterate while l1 or l2 or carry because as long as one of them exists, we still need to add digits to our number.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Traverse two lists simultaneously, adding the nodes together like you would add two numbers together digit-by-digit (with a carry). 2) Dummy node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Linked List                                                                       | M | [](https://leetcode.com/problems/odd-even-linked-list/)[328](https://leetcode.com/problems/odd-even-linked-list/)                                                                                                                                        |                                                                                                                                                                                                                                                                                      | Odd Even Linked List                                                        | While even and even.next, update odd and even's next references, then join at end.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Pointer manipulation                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Reverse List                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Reversing a linked list in place.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Linked List / Recursion                                                           | E | [](https://leetcode.com/problems/reverse-linked-list/)[206](https://leetcode.com/problems/reverse-linked-list/)                                                                                                                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC206-reverseLinkedList.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC206-reverseLinkedList.py)                                                                               | Reverse Linked List                                                         | The tricky parts to this problem are: startin with prev = None, creating a tmp variable to store head.next, and returning prev. Using a tmp variable to store a reference that will be overwritten is a very common practice with linked list problems.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: Reverse a linked list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Linked List                                                                       | H | [](https://leetcode.com/problems/reverse-nodes-in-k-group/)[25](https://leetcode.com/problems/reverse-nodes-in-k-group/)                                                                                                                                 |                                                                                                                                                                                                                                                                                      | Reverse Nodes in k-Group                                                    | Reverse LL in k-groups. Use getKth hepler. Iterate while True, return when not kth.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Reverse linked list in k-groups. 2) Dummy node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Slow & Fast                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Linked List                                                                       | E | [](https://leetcode.com/problems/middle-of-the-linked-list/)[876](https://leetcode.com/problems/middle-of-the-linked-list/)                                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC876-middleOfLinkedList.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC876-middleOfLinkedList.py)                                                                             | Middle of the Linked List                                                   | This is one of the linked list problems where you have to pay close attention to off-by-one errors. Firstly, you have to think about where you want the fast and slow pointers to start. Then you have to think about lists with an odd number of nodes or an even number of nodes. You have to run through test casees to prove to your interviewer that the algorithm works for all reasonable cases.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Find the middle node in a linked list using slow & fast pointers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Linked List                                                                       | E | [](https://leetcode.com/problems/linked-list-cycle/)[141](https://leetcode.com/problems/linked-list-cycle/)                                                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC141-linkedListCycle.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC141-linkedListCycle.py)                                                                                   | Linked List Cycle                                                           | This is the classic example of a slow and fast pointer problem. It is also referred to as Floyd's cycle or hair-tortoise. The idea is that two pointers will always converge on each other if one is increasing in distance from the other by 1 at each iteration, which, in a cycle, means they are actually getting closer by 1 at each iteration.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Concept: 1) Detect if there is a cycle in a linked list using slow & fast pointers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Delete Nodes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Linear traversal of a linked list with logic to update pointers to skip over certain nodes, essentially deleting them.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Linked List                                                                       | E | [](https://leetcode.com/problems/remove-linked-list-elements/)[203](https://leetcode.com/problems/remove-linked-list-elements/)                                                                                                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC203-removeLinkedListElements.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC203-removeLinkedListElements.py)                                                                 | Remove Linked List Elements                                                 | We need a dummy reference because there is an edge case where a node to be removed is the head node. In that case, we need a node before the head node. With these reference changing problems in-place in O(N) time, it really is just a matter of coming up with an ad hoc traversal and update algorithm. What we do know at the start is we need a dummy and we have to update while cur. We also know that if cur.val == val, we want to update cur's previous node to point to cur's next node. The important next idea is to not update prev yet. If shift prev and cur's next also has a val == val, we lose the reference to prev to update it's next reference ahead again. This edge case is when 2 or more nodes together have a val == val. After being able to reason through this, the code then becomes fairly trivial.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Remove nodes from linked list that match a provided value. Very similar to LC 83 and LC 1836.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Linked List                                                                       | M | [](https://leetcode.com/problems/merge-nodes-in-between-zeros/)[2181](https://leetcode.com/problems/merge-nodes-in-between-zeros/)                                                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC2181-mergeNodesInBetweenZeros.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC2181-mergeNodesInBetweenZeros.py)                                                               | Merge Nodes in Between Zeros                                                | Since we will always remove the first node from the list, we don't need a dummy node. And since we are guaranteed to have three nodes, the first and last of which being 0's, we can start our traversal with prev being the first node after the first 0 and cur being the second node after the first 0. Then we can use two cases for each step: If the current value is 0, we update prev. If the current value is not 0, we increment prev by the current value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Merge nodes values together between a target value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Kth From End                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Use two pointers: left and right. Move the right pointer across the linked list until the gap between the left and right pointer will leave the left pointer at the desired node when iterating both at the same time until right is null.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Linked List                                                                       | M | [](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/description/)[1721](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/description/)                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC1721-swappingNodesInALinkedList.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC1721-swappingNodesInALinkedList.py)                                                           | Swapping Nodes in a Linked List                                             | This is a common subpattern in linked list problems where you have to find the kth node from the end of the list. To do this, we use a left and right pointer. The right pointer will be used to stop when we hit a null node. Then we want the gap between the left and right pointer to be such that the left pointer is at the kth node from the end of the linked list when right is null. There are many ways you can code this, but the general way is to first create the necessary gap between left and right by shifting right forward, then shift left and right simultaneously until right.next is null (or right is null depending on how you want to code it).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Find kth node from beginning and kth from end of a linked list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Linked List                                                                       | M | [](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)[19](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)                                                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC19-removeNthNodeFromEndOfList.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC19-removeNthNodeFromEndOfList.py)                                                               | Remove Nth Node From End of List                                            | We use a dummy node because the node to remove could be the first node. So we need a reference to the node before it, which in this case has to be a dummy node that we create. The first while loop is essentially creating a gap between left and right so that when right is eventually None on the second loop, our left pointer is at the node before the node we want to remove.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Remove Nth node from end of list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Doubly-linked List                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Linked List / Doubly-Liked List / Hash Map                                        | M | [](https://leetcode.com/problems/lru-cache/)[146](https://leetcode.com/problems/lru-cache/)                                                                                                                                                              |                                                                                                                                                                                                                                                                                      | LRU Cache                                                                   | Doubly linked list. A seemingly common interview question for linekd list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Use a doubly-linked list to implement an LRU cache.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Linked List / Doubly-Liked List                                                   | M | [](https://leetcode.com/problems/design-circular-queue/)[622](https://leetcode.com/problems/design-circular-queue/)                                                                                                                                      |                                                                                                                                                                                                                                                                                      | Design Circular Queue                                                       | Linked list. Left and right nodes. Enque right, deque left. Use self.space for space left.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Doubly-linked list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Misc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Linked List                                                                       | M | [](https://leetcode.com/problems/sort-list/)[148](https://leetcode.com/problems/sort-list/)                                                                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC148-sortList.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC148-sortList.py)                                                                                                 | Sort List                                                                   | We can treat sortList() as a recursive method. We use left and right variables as the start of the left list and the right list after the mid node respectively. To get the right node after mid, we implement a getMid() helper method. Once we have references to both left and right lists, we then return the merged list of these two lists, which is implemented as a helper method merge(). This returned merged list will return back up the recursive tree so that previous calls can use this merged list to merge with the other list in that execution context.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Use merge sorted linked list idea in conjunction with the merge sort idea.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Linked List / Hash Map                                                            | M | [](https://leetcode.com/problems/copy-list-with-random-pointer/)[138](https://leetcode.com/problems/copy-list-with-random-pointer/)                                                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC138-copyListWithRandomPointer.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC138-copyListWithRandomPointer.py)                                                               | Copy List with Random Pointer                                               | Seed the old_to_new hash map with None : None because we will get a key error for None otherwise. The reason we need to do two passes is because the first pass is to create new instances of the old nodes, but we can't reference next or random because next hasn't been create yet and random could be any node. This is why we make sure we have every possible node in the hash map before we try to update pointers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Create deep copy of linked list that has a random pointer.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Sliding Window                                                                    |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      | 34                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Static Size                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Thw window size does not change.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| String / Sliding Window                                                           | E | [](https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/)[2379](https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/)                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2379-minimumRecolorsToGetKConsecutiveBlackBlocks.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2379-minimumRecolorsToGetKConsecutiveBlackBlocks.py)                   | Minimum Recolors to Get K Consecutive Black Blocks                          | Since we have to get the minimum recolors out of all the size k windows, this is a sliding window problem of fixed size. To solve the problem, we just have to find the minimum number of white blocks in each k-size window. As a side note, since we are minimizing, we want to start the answer as float('inf'). You always want to start the value we are trying to minimize/maximize as the opposite infinite value so no matter how extreme an edge case gets, we will still update the value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Concept: 1) Static-size dynamic window. 2) Find minimum frequency of a specific element in the sliding window of size k.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| String / Sliding Window                                                           | M | [](https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/)[1888](https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/)                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1888-minimumNumberOfFlipsToMakeTheBinaryStringAlternating.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1888-minimumNumberOfFlipsToMakeTheBinaryStringAlternating.py) | Minimum Number of Flips to Make Binary String Alternating                   | We can use a sliding mask to compare the current number to strings that alternate starting with 0/1, maintaining a difference count for each mask. We can do this for a string that is two copies of the original string to explore all possible situations where we remove a character from the start of the string and append it to the end.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Static-size sliding window. 2) Double string to simulate possibilities of moving left element to end.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| String / Hash Map / Sliding Window                                                | M | [](https://leetcode.com/problems/find-all-anagrams-in-a-string/)[438](https://leetcode.com/problems/find-all-anagrams-in-a-string/)                                                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC438-findAllAnagramsInAString.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC438-findAllAnagramsInAString.py)                                                           | Find All Anagrams in a String                                               | Since we are limited to 26 characters, the space complexity can be at most 26 entries for each hash map, or 52 total, which is O(1) since any constant is just O(1). This is considered a fixed-window size sliding window problem because our window size is not dynamic. It is constantly the length of p. This is because no substring can be an anagram of p if it is shorter or longer. it has to be the exact length of p. Because of this, the updating of the window indices is trivial for these problems.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Static-size sliding window with implicit window size. 2) Hash map to keep track of window character counts.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Array / Sliding Window                                                            | M | [](https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together-ii/)[2134](https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together-ii/)                                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2134-minimumSwapsToGroupAll1sTogetherII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2134-minimumSwapsToGroupAll1sTogetherII.py)                                     | Minimum Swaps to Group All 1's Together II                                  | Reall good sliding window problem that introduces the idea of finding a window size based on the elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Static-size sliding window with implicit window size. 2) Duplicate array to mimic circular array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Array / Queue / Sliding Window                                                    | H | [](https://leetcode.com/problems/sliding-window-maximum/)[239](https://leetcode.com/problems/sliding-window-maximum/)                                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC239-slidingWindowMaximum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC239-slidingWindowMaximum.py)                                                                   | Sliding Window Maximum                                                      | We use a monotonically decreasing queue so the max in each window is present in the queue. We can pop because those numbers will never be the max if the current number is larger. We have to popleft with two different conditions because we can either have a situation where the queue is larget than k and also we could have got rid of every other element in the queue, leaving one element. If we pop this new element and the next element is smaller than the popped element, we would append the smaller element to the answer array, which is incorrect.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Static-size sliding window with an explicit window size. 2) Use a monotonically increasing queue for the window to have efficient access to the maximum element of the window on the right and to pop from the left when shrinking from the left.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Dynamic: Minimize                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | The window size is not specified. Problems that ask to minimize the window.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Array / Sliding Window                                                            | M | [](https://leetcode.com/problems/minimum-size-subarray-sum/)[209](https://leetcode.com/problems/minimum-size-subarray-sum/)                                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC209-minimumSizeSubarraySum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC209-minimumSizeSubarraySum.py)                                                               | Minimum Size Subarray Sum                                                   | This is a standard dynamic-size sliding window problem. To do a dyanmic-size sliding window algorithm for the context of this problem, use a for loop to always add the right value to the window sum. After adding it to the window sum, update min_len with the minimum of min_len and the current window size and shrink the left side while we are still greater than or equal to the target value. The window will continue shrinking until our win_sum is < target. This works because we are building up to a target sum. So the values between left and right will never have to be recomputed since they can never equal the target sum on their own after we break out of the while loop.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Dynamic-size minimize sliding window. Shrink from left when target is met until target is not met.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Array / Hash Map / Sliding Window                                                 | M | [](https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/description/)[2260](https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/description/)                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2260-minimumConsecutiveCardsToPickUp.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2260-minimumConsecutiveCardsToPickUp.py)                                           | Minimum Consecutive Cards to Pick Up                                        | This is a sliding window of dynamic size because the length of the sliding window is unknown. We want to stop expanding the sliding window when we find a duplicate card. We stop expanding because we want to minimize the window that contains a matching. So when we find a matching, we shrink from the left and keep trying to update the min_consec. When we shrink the window to a point where there is no matching, we try to grow the window size again.We use a cur_max_count so we don't have to continuously call max(card_counts.values()) in the while loop condition, which gives TLE. It's faster to maintain/check 1 variable's value rather than going through all values in card_counts.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Dynamic-size sliding window. 2) Minimizing sliding window. 3) Minimum window size with 2 of the same element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Array / Hash Map / Sliding Window                                                 | H | [](https://leetcode.com/problems/minimum-window-substring/)[76](https://leetcode.com/problems/minimum-window-substring/)                                                                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC76-minWinSubstring.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC76-minWinSubstring.py)                                                                               | Minimum Window Substring                                                    | This is a subpattern of sliding window that I like to call 'dynamic-sized'. This means that the window is growing or shrinking depending on certain criteria, or essentially we do not know what the window size will be during iteration. Using a left pointer starting at 0 and iterating through the array with a for loop using a right pointer has worked for the problems I can think of off of the top of my head, but there may be other questions that require a different traversal. As for the other trick to this problem which makes it a hard is comparing the counts of the window hash map and the t count hash map. Using have and need variables chances the time complexity from O(26) for checking every character in both hash maps to O(1) where we only need to check 1 variable (have).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Dynamic-size minimize sliding window. Shrink from left when target is met until target is not met. 2) Use extra variables to track constraint to avoid comparing window character counts to target string character counts at each iteration.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Sliding Window                                                                    | M | [](https://leetcode.com/problems/replace-the-substring-for-balanced-string/description/)[1234](https://leetcode.com/problems/replace-the-substring-for-balanced-string/description/)                                                                     |                                                                                                                                                                                                                                                                                      | Replace the Substring for Balanced String                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Dynamic-size sliding window minimizing. 2) Get excess count of elements and get minimum window that has the excess elements in it. 3) Minimum with AT LEAST k elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Dynamic: Maximize                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | The window size is not specified. Problems that ask to maximize the window. Important: Sometimes shrinking from left only needs to be done by 1 because maximum is now that window size, but this depends on the constraint. If the right element being in the window breaks all windows with this element, update left index to right or right + 1, again depending on constraint.                                                                                                                                                                                                                                                                                                                                                                                                            |
| String / Sliding Window / Hash Map                                                | M | [](https://leetcode.com/problems/longest-substring-without-repeating-characters/)[3](https://leetcode.com/problems/longest-substring-without-repeating-characters/)                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC3-longestSubstringWithoutRepeatingCharacters.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC3-longestSubstringWithoutRepeatingCharacters.py)                           | Longest Substring Without Repeating Characters                              | This is a sliding window of dynamic size. It is important to distinguish these between fixed-size sliding windows so you can generalize approaches to apply them to other problems. For this approach, the dynamic nature is with the while loop that shrinks the window until s[right] is not in the window.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Dynamic-size maximizing sliding window. 2) Hash set to keep track of window characters. 3) While window constraint is broken, remove left value from window data structure and increment left by 1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Sliding Window / Hash Map                                                 | M | [](https://leetcode.com/problems/fruit-into-baskets/description/)[904](https://leetcode.com/problems/fruit-into-baskets/description/)                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC904-fruitIntoBaskets.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC904-fruitIntoBaskets.py)                                                                           | Fruit Into Baskets                                                          | Similar to LC 159 and LC 340. This is a dynamic size subpattern because the length of the sliding window is unknown. The problem description is verbose, but the pattern follows a standard dynamic sliding window approach where we add the newly seen element at the right index to a collection, shrink the left side of the sliding window while we passed our condition, and then take the maximum of the current maximum and our current window size.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Dynamic-size sliding window. 2) Constraint is a maximum number of unique elements in the window.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Sliding Window / String                                                           | M | [](https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/description/)[2414](https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/description/)                                         |                                                                                                                                                                                                                                                                                      | Length of the Longest Alphabetical Continuous Substring                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Dynamic-size sliding window. 2) Ordinal values.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Dynamic: Maximize With Replacements                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | The window size is not specified. Problems that ask to maximize the window. Problems that also allow you to replace some k elements in the window. Expand until condition with replacements breaks. Then shrink from left until condition becomes true again.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Array / Sliding WIndow                                                            | M | [](https://leetcode.com/problems/max-consecutive-ones-iii/)[1004](https://leetcode.com/problems/max-consecutive-ones-iii/)                                                                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1004-maxConsecutiveOnesIII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1004-maxConsecutiveOnesIII.py)                                                               | Max Consecutive Ones III                                                    | Note: this is the same exact implementation as "Max Consecutive Ones II", except instead of only being allowed one 0, we can have k 0's. This is a dynamic size subpattern because the length of the sliding window is unknown. For each iteration, we check if the new num we are adding to our window on the right is equal to 0 or 1. If it is 0, we increment the zero_count by 1. Since we can only replace k 1's, we shrink the left size until the zero_count of our window becomes k. (This while loop won't need to execute if there is up to k 0's in the window). Then when we reach the end of each iteration, we can take the max of the current window length and the current max because at this point in the iteration we are guaranteed to have less than k + 1 0's in our window.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Dynamic-size sliding window with replacements. 2) Count variable to keep track of replacements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| String / Hash Map / Sliding WIndow                                                | M | [](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/)[2024](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/)                                                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2024-maximizeTheConfusionOfAnExam.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2024-maximizeTheConfusionOfAnExam.py)                                                 | Maximize the Confusion of an Exam                                           | This is a sliding window of dynamic size because the length of the sliding window is unknown. This problem is nearly identical to LC 424 - "Longest Repeating Character Replacement" in form. The idea is to try to expand the sliding window to the right as long as the difference between the window length and the max of t_count/f_count is less than or equal to k. This essentially means, expand the window until we exhaust k possible replacements. We do window size - max of t/f because that produces the frequency of the minimum character of the two. An important idea to wrap your head around as well is with the shrinking of the left side. We only shrink it by at most 1 time per for loop iteration (a lot of problems shrink the window size using a while loop for some condition) because we got the max sliding window size so far, so decreasing by one and adding by one at each subsequent iteration does no harm to finding the maximized final result. Once we get the current max, there is no reason to shrink smaller than max when we are trying to maximize WINDOW LENGTH. Do some examples to justify this to yourself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Dynamic-size sliding window. 2) Max consecutive with k replacements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Array / Sliding WIndow                                                            | M | [](https://leetcode.com/problems/frequency-of-the-most-frequent-element/)[1838](https://leetcode.com/problems/frequency-of-the-most-frequent-element/)                                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1838-frequencyOfTheMostFrequentElement.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1838-frequencyOfTheMostFrequentElement.py)                                       | Frequency of the Most Frequent Element                                      | The trick is to understand that we can sort the nums and then compare the right side of a sliding window \* the length of the sliding window to the current sum of the sliding window to check how many operations are needed to make all numbers equal. This will be our shrinking rule.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Dynamic-size maximizing sliding window with replacements. 2) When condition (with replacements) is not met, shrink from left by 1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Dynamic: Maximize Contiguous Constraint                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | The window size is not specified. Problems that require you to match the window with a contiguous sequence of elements. For example: Instead of longest subarray of sum <= k, do longest subarray of values == 5. The implementation difference generally means each element in the window isn't contributing to our window beyond it just being a part of the length (with sum you add the number to a running sum, with contiguous you don't) AND the window is now completely useless, so this is why we update left to right or right + 1 index.                                                                                                                                                                                                                                           |
| Array / Sliding Window                                                            | E | [](https://leetcode.com/problems/max-consecutive-ones/)[485](https://leetcode.com/problems/max-consecutive-ones/)                                                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC485-maxConsecutiveOnes.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC485-maxConsecutiveOnes.py)                                                                       | Max Consecutive Ones                                                        | This is the dynamic size subpattern because the length of the sliding window is unkown. For each iteration, we have two choices: 1) If nums[right] is a 1, attempt to update max_consec with the current size of the array. 2) Nums[right] isn't a 1, so we update left to right + 1 since that is the next possible start of the max consecutive ones.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Dynamic-size maximizing sliding window. 2) When window constraint is broken, update left index to right + 1 since entire window is invalid.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Array / Sliding Window                                                            | M | [](https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/description/)[2110](https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/description/)                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2110-numberOfSmoothDescentPeriodsOfAStock.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2110-numberOfSmoothDescentPeriodsOfAStock.py)                                 | Number of Smooth Descent Periods of a Stock                                 | To count the number of subarrays we can use a sliding window technique. We start the count at 1 because our algorithm only adds the 1-length subarray at the right index, and we want left and right to start at 0 and 1 respectively for the first comparison (this just cleans up the code so you don't have to encode an exrta case in the for loop). The number of subarrays is right - left + 1 if the value at the right index extends the current smooth descent period, otherwise the number of subarrays is 1 (itself).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Dynamic-size contiguous adjacent constraint sliding window. 2) Count subarrays using formula n \* (n + 1) / 2. 3) If window constraint is broken (left and right values are not equal), update answer and update left index to right index.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Dynamic: Count Subs                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Add to window until condition is true, then shrink from left until condition is false. The left index will then be the number of new subarrays we can add to the count of subarrays that end at the current right index who adhere to the constraint of AT LEAST x items.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| String / Hash Map / Sliding Window                                                | M | [](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/description/)[1358](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/description/)                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1358-numberOfSubstringsContainingAllThreeCharacters.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1358-numberOfSubstringsContainingAllThreeCharacters.py)             | Number of Substrings Containing All Three Characters                        | This is a dynamic size subpattern because the length of the sliding window is unkown. Since we are COUNTING ALL substrings of ANY size that include the three characters AT LEAST ONCE, it is not sufficient enough to iterate until we have a window with all 3 characters and shrink the left side, counting each window that meets the requirements. That approach would miss counting all of the substrings that can START at those indices we discard in future windows. So we instead count the left index doing the following: Upon exiting from the while loop, all the substrings starting at indices 0, 1 … (left - 1) and ending at right satisfies the condition. Since there are 'left' such strings, we add left to substr_count.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Dynamic-size sliding window counting subarrays. 2) Counting number of subarrays that have AT LEAST some number of specified elements. 3) Add left index to count after shrinking left side to break the condition because the index is the number of different starting positions a subarray can start at and end at the right index that adhere to the constraint.                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Sliding Window                                                            | H | [](https://leetcode.com/problems/count-subarrays-with-score-less-than-k/description/)[2302](https://leetcode.com/problems/count-subarrays-with-score-less-than-k/description/)                                                                           |                                                                                                                                                                                                                                                                                      | Count Subarrays With Score Less Than K                                      | Thinking process: With each newly added element, shrink window from left until a valid window is made. Then every subarray in this window is valid. IMPORTANT: The number of subarrays is 1 + 2 + 3 ... + n, or n \* (n + 1) / 2. So it is sufficient to add the length of the sliding window to the count every time it is valid to get the answer.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Concept: 1) Dynamic-size sliding window with contiguous constraint. 2) Count subarrays with value less than K. 3) Count subarrays by getting valid window and adding length of window to subarray count.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Array / Sliding Window                                                            | M | [](https://leetcode.com/problems/count-number-of-nice-subarrays/description/)[1248](https://leetcode.com/problems/count-number-of-nice-subarrays/description/)                                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1248-countNumberOfNiceSubarrays.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1248-countNumberOfNiceSubarrays.py)                                                     | Count Number of Nice Subarrays                                              | Extremely similar to LC 560 Subarray Sum Equals to K. The reason this is different from something like LC 1358 is because we need EXACTLY k items. If we have AT LEAST k items constraint, technically we could start every subarray from the beginning. But with EXACTLY k items, we need a different approach. This problem can be solved with sliding window or prefix sums. Can be solved with sliding window OR prefix sums. For sliding window approach, shift thinking to use "AT MOST K" because this can be solved with sliding window. Then do AT MOST K - AT MOST K - 1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Sliding window of dynamic size. 2) Count subarrays with non-contiguous constraint of EXACTLY k items.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Array / Hash Map / Sliding Window                                                 | H | [](https://leetcode.com/problems/subarrays-with-k-different-integers/description/)[992](https://leetcode.com/problems/subarrays-with-k-different-integers/description/)                                                                                  |                                                                                                                                                                                                                                                                                      | Subarrays with K Different Integers                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Cannot converge to constraint based on window size. 2) Get (count of subarrays with AT MOST k) - (count of subarrays with AT MOST k - 1) to get count of subarrays with k.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Dynamic: Count Contiguous Subs                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Count substrings with contiguous constraint. Expand until window is invalid. Then count number of subarrays and update left pointer to right + 1 since this will be the potential start of the next window. Different from Count Subs because with contiguous constraint, entire window breaks when constraint fails.                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Array / Sliding Window                                                            | M | [](https://leetcode.com/problems/number-of-zero-filled-subarrays/description/)[2348](https://leetcode.com/problems/number-of-zero-filled-subarrays/description/)                                                                                         |                                                                                                                                                                                                                                                                                      | Number of Zero-Filled Subarrays                                             | Good problem. Can use math equation to calculate number of problems given a subarray length.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Concept: 1) Dynamic-size contiguous element sliding window. 2) Count subarrays using formula n \* (n + 1) / 2. 3) If window constraint is broken (left and right values are not equal), update answer and update left index to right index + 1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| String / Sliding Window                                                           | M | [](https://leetcode.com/problems/count-number-of-homogenous-substrings/)[1759](https://leetcode.com/problems/count-number-of-homogenous-substrings/)                                                                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1759-countNumberOfHomogenousSubstrings.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1759-countNumberOfHomogenousSubstrings.py)                                       | Count Number of Homogenous Substrings                                       | This approach relies on knowing that you can calculate the number of substrings in a string of length n by doing 1 + 2 + 3 + … n. So for each char, if is the same as all the others in the current substring, we can add the length of the current substring to the count. To understand how this works, think about the number of ways you can choose indices i and j when creating substrings with a double for loop. When i == j, we only have 1 way. When j = i + 1, we have two more ways, and for j = i + 2, we have 3 more ways and so on. Note: On the surface, this problem seems to be similar to LC 1358 - Number of Substrings Containing All Three Characters, but they are different in an important way. We know when we increase the substring length, the property we need (homogenous) is True for every substring. This is NOT the case for LC 1358, so we can't do the 1 + 2 + 3 ... approach.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Dynamic-size contiguous element sliding window. 2) Count subarrays using formula n \* (n + 1) / 2. 3) If window constraint is broken (left and right values are not equal), update answer and update left index to right index.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Matrix                                                                            |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | 2D Prefix Sums                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Matrix / Prefix                                                                   | M | [](https://leetcode.com/problems/range-sum-query-2d-immutable/)[304](https://leetcode.com/problems/range-sum-query-2d-immutable/)                                                                                                                        |                                                                                                                                                                                                                                                                                      | Range Sum Query 2D - Immutable                                              | Similar to LC 1314                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Use 2D prefix sums to calculate range sums from each cell.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Trivial Search                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Depth-First Search, Depth-First Search, while loop                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Matrix / Hash Set / Queue / Depth-First Search / Breadth-First Search / Recursion | E | [](https://leetcode.com/problems/flood-fill/)[733](https://leetcode.com/problems/flood-fill/)                                                                                                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC733-floodFill.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC733-floodFill.py)                                                                                                             | Flood Fill                                                                  | You don't need a visited set because changing the cells as we go means we will never try to visit that cell again anyway. A reasonable question to have with these DFS/BFS problems is: which one to use? The answer is always: it depends. But, for this problem the only thing to worry about is the size of the grid. DFS uses stack space and stack space is limited. But we see in the problem constraints for this problem, the grid can be no bigger than 50x50. So DFS will not run into stack frame limitations.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) DFS. 2) BFS. 3) Change matrix during DFS/BFS traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Matrix / Hash Set / Queue / Depth-First Search / Breadth-First Search / Recursion | M | [](https://leetcode.com/problems/number-of-enclaves/)[1020](https://leetcode.com/problems/number-of-enclaves/)                                                                                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1020-numberOfEnclaves.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1020-numberOfEnclaves.py)                                                                                             | Number of Enclaves                                                          | To think about this problem in a different way, we can try to find all cells that are connected to the boundary and then not include those in our enclave count. This is why we search from the boundary cells only. There are many other ways to solve the problem, but this is a pretty clean way. Similar to LC 130.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Depth-First Search. 2) Breadth-First search. 3) Capture (traverse and add to visited) some cells and then do a separate traversal on the remaining unvisited cells.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Matrix                                                                            | M | [](https://leetcode.com/problems/queens-that-can-attack-the-king/description/)[1222](https://leetcode.com/problems/queens-that-can-attack-the-king/description/)                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1222-queensThatCanAttackTheKing.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1222-queensThatCanAttackTheKing.py)                                                                         | Queens That Can Attack the King                                             | This is a good problem to be made aware of and practice 8-directional grid movement. Using a directions array is the cleanest way to do this. Also using a helper function for doing the search for each direction helps clean up the code.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) 8-directional movement.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Matrix / Hash Set / Queue / Depth-First Search / Breadth-First Search / Recursion | M | [](https://leetcode.com/problems/maximum-number-of-fish-in-a-grid/)[2658](https://leetcode.com/problems/maximum-number-of-fish-in-a-grid/)                                                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC2658-maximumNumberOfFishInAGrid.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC2658-maximumNumberOfFishInAGrid.py)                                                                         | Maximum Number of Fish in a Grid                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) DFS. 2) BFS. 3) Sum of maximum path.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Matrix / Hash Set / Queue / Depth-First Search / Breadth-First Search / Recursion | M | [](https://leetcode.com/problems/max-area-of-island/)[695](https://leetcode.com/problems/max-area-of-island/)                                                                                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC695-maxAreaOfIsland.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC695-maxAreaOfIsland.py)                                                                                                 | Max Area of Island                                                          | For the cur_sum += dfs(nei_r, nei_c), think of the last call. The cur_sum will be 1 but will have no neighbors, so it will return 1. The previous call will have a cur_sum of 1 and will be adding the return value of 1 from the other DFS, so now cur_sum is 2. It's like a tree. We are adding one to our caller, and it keeps doing that until it gets back to the root. This is how the cur_sum is added.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) DFS. 2) BFS. 3) Getting size of a search.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Multisource BFS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Think of it as an infection spreading from multiple sources breadth-wise. At each step, every source goes to all of its adjacent positions.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Matrix / Hash Set / Queue / Breadth-First Search                                  | M | [](https://leetcode.com/problems/rotting-oranges/)[994](https://leetcode.com/problems/rotting-oranges/)                                                                                                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC994-rottingOranges.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC994-rottingOranges.py)                                                                                                   | Rotting Oranges                                                             | We are traversing the grid, which immediately brings you to think DFS or BFS as they are the two grid/graph traversal algorithms that cover most gird/graph traversal problems. But why do we go with BFS? Because of the nature of the traversal. At every time increment, we want to change everything around the oranges that were rotted last. This is a blatant traversal in a breadth-first manner. Treating every level of the BFS traversal as 1 minute makes this problem easy to understand as far as how to approach it with code.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Multi-source BFS.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Matrix / Hash Set / Queue / Breadth-First Search / Shortest Path                  | M | [](https://leetcode.com/problems/01-matrix/)[542](https://leetcode.com/problems/01-matrix/)                                                                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC542-O1Matrix.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC542-O1Matrix.py)                                                                                                               | 01 Matrix                                                                   | "Distance to multiple cells" problems like this problem and LC 286 "Walls and Gates" can be solved by using the cells we want to reach as the source nodes for a multi-source BFS. If you think about it logically with a level-by-level traversal, it makes sense because at the destination cells it takes a distance of 0 to get to them. Then we can expand outward using BFS, add 1 to the distance and so on. Whereas if you start from any random cell, it isn't guaranteed that starting at this cell will produce an optimal path to a target. But starting from the target will ensure it is taking the optimal path backward.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Concept: 1) If asked to find distance to nearest y thing from x, always flip thinking to go from x to y. Meaning change the target to the source. The reason we do this is because it's easier to assign distances this way. This approach becomes even more relevant in the Walls and Gates problem.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Matrix / Hash Set / Queue / Breadth-First Search / Shortest Path                  | M | [](https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/)[1926](https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/)                                                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1926-nearestExitFromEntranceInMaze.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1926-nearestExitFromEntranceInMaze.py)                                                                   | Nearest Exit from Entrance in Maze                                          | Seeding the queue and visited sets is kind of ugly using indexing, so you can unpack the entrance list into two variables and create a tuple to make it a bit cleaner. For the check if the current cell is not the entrance, a clean way to write this is [r, c] != entrance.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) BFS. 2) Shortest path in a matrix with obstacles.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Unweighted Shortest Path                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | BFS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Matrix / Hash Set / Queue / Breadth-First Search / Shortest Path                  | M | [](https://leetcode.com/problems/shortest-path-in-binary-matrix/)[1091](https://leetcode.com/problems/shortest-path-in-binary-matrix/)                                                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph%20Traversal/LC1091-shortestPathinBinaryMatrix.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph%20Traversal/LC1091-shortestPathinBinaryMatrix.py)                                                   | Shortest Path in Binary Matrix                                              | Why do we use a standard BFS over Dijkstra's here, specifically using a queue instead of a min heap? Because the weights are constant (the cost to go between all adjacent cells is always 1). Can we still use Dijkstra's? Yes, but it is overkill as we don't need a priority queue because every distance to neighboring cells at each level is the same, so we don't need the sorted property of a min heap, so appending to and popping from a queue will be faster than adding to and removing from a min heap. But what if we need to keep track of shortest paths to each node? You can just declare a distances array like Dijkstra's does and add the distance to the repsective location in the array when it is first seen (again, it will never be updated after it is seen for the first time). One thing we lose from Dijkstra's that we need to add is visited checking logic. With Dijkstra's you check if the new path is shorter than old path, which with constant weight problems acts like a visited check, so with standard BFS make sure to use a visited set.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Shorest path in a matrix with constant weights (BFS).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Matrix / Hash Set / Queue / Breadth-First Search / Shortest Path                  | H | [](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/description/)[1293](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/description/)                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC1293-shortestPathInAGridWithObstacles.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC1293-shortestPathInAGridWithObstacles.py)                                                               | Shortest Path in a Grid with Obstacles Elimination                          | Since each traversal from cell to cell is unweighted, we use BFS. Since each path will have its own choices of removing obstacles, we encode the current obstacles removed in each queue element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) Shortest path in a matrix with obstacles and unweighted edges using BFS.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Weighted Shortest Path                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Dijkstra's                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Matrix / Heap / Shortest Path                                                     | M | [](https://leetcode.com/problems/path-with-minimum-effort/)[1631](https://leetcode.com/problems/path-with-minimum-effort/)                                                                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1631-pathWithMinimumEffort.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1631-pathWithMinimumEffort.py)                                                                                   | Path With Minimum Effort                                                    | When you pop an entry from the min heap that is the destination cell, you will always have the minimum path value up until this cell and you will only find larger paths if you keep checking for shorter paths. This is because we are optimally choosing a path up until this point due to the priority queue.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Dijkstra's on a matrix .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Matrix / Heap / Shortest Path                                                     | H | [](https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/description/)[2577](https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/description/)                                                                           |                                                                                                                                                                                                                                                                                      | Minimum Time to Visit a Cell In a Grid                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Dijkstra's on a matrix .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Matrix / Heap / Shortest Path                                                     | H | [](https://leetcode.com/problems/swim-in-rising-water/)[778](https://leetcode.com/problems/swim-in-rising-water/)                                                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph%20Traversal/Shortest%20Path/Dijkstra's/LC778-swimInRisingWater.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph%20Traversal/Shortest%20Path/Dijkstra's/LC778-swimInRisingWater.py)                 | Swim in Rising Water                                                        | An easier way to think about the problem is just as a shortest path problem since you can travel infinite distance in one iteration. But the shortest path for this problem is the shortest max height of all paths to the ending cell. This means we try to minimize the tallest cell we need to traverse. So for each iteration that would be the distance of a path in a 'regular' Dijkstra's problem is actually the max of all cells along the current path. We calculate this with 'nei_time = max(time, grid[nei_row][nei_col]). The times array acts both as a visited set and a record for the shortest max height to each cell. Keep in mind that we put the time as the first element in our pairs for the min heap because we want the min heap to pop pairs with the shortest current max.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Column-wise Traversal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Matrix                                                                            | E | [](https://leetcode.com/problems/find-the-width-of-columns-of-a-grid/description/)[2639](https://leetcode.com/problems/find-the-width-of-columns-of-a-grid/description/)                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC2639-findTheWidthOfColumnsOfAGrid.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC2639-findTheWidthOfColumnsOfAGrid.py)                                                                     | Find the Width of Columns of a Grid                                         | The naïve approach would be to traverse the matrix row-wise and store the max for each column and update the max and min at each cell. This uses extra space. We can traverse the matrix column-wise and just keep track of the max length for the current row.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Traverse a grid column-wise instead of row-wise.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Diagonals                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Matrix                                                                            | E | [](https://leetcode.com/problems/check-if-matrix-is-x-matrix/description/)[2319](https://leetcode.com/problems/check-if-matrix-is-x-matrix/description/)                                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC2319-checkIfMatrixIsX-Matrix.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC2319-checkIfMatrixIsX-Matrix.py)                                                                               | Check if Matrix is X-Matrix                                                 | To check if grid[r][c] is on the negative diagonal, check if r + c == n - 1. To check if grid[r][c] is on the positive diagonal, check if r == c.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) Use row and column indices to check if cell is a part of positive or negative diagonal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Matrix / Hash Map / Heap                                                          | M | [](https://leetcode.com/problems/sort-the-matrix-diagonally/)[1329](https://leetcode.com/problems/sort-the-matrix-diagonally/)                                                                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1329-sortTheMatrixDiagonally.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1329-sortTheMatrixDiagonally.py)                                                                               | Sort the Matrix Diagonally                                                  | An important concept for this problem is being able to uniquely identify each diagonal. For this problem, we are asked for the primary diagonal (top left to bottom right). Each cell in its respective diagonal have the same result for its row index subtracted by its column index. So we can have a defaultdict of lists and append the cell's value to the list by doing diagonals[row-col].append(matrix[row][col]). This accesses the row-col diagonal and appends the value at the cell to its diagonal list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Row - column index is how to uniquely identify each negative diagonal of a matrix.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Hash Map                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Matrix / Hash Map                                                                 | M | [](https://leetcode.com/problems/equal-row-and-column-pairs/description/)[2352](https://leetcode.com/problems/equal-row-and-column-pairs/description/)                                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2352-equalRowAndColumnPairs.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2352-equalRowAndColumnPairs.py)                                                                         | Equal Row and Column Pairs                                                  | Using a hash map or hash set to record all the rows (make sure to use tuples since arrays cannot be hashed) allows us to then check the columns, and if the column tuple is present in the hash map/hash set, add it to the total.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Use a hash map to store a tuple of each row. 2) Check if the tuple of each column is in the row hash map.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Hash Set                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Typically hash map of hash sets. Where each key is the row/col index and each value is a set of the row/col values.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Matrix / Hash Set                                                                 | E | [](https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/description/)[2133](https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/description/)                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2133-checkIfEveryRowAndColumnContainsAllNumbers.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2133-checkIfEveryRowAndColumnContainsAllNumbers.py)                                 | Check if Every Row and Column Contains All Numbers                          | The O(1) approach is to mark corresponding row/col negative and check if its already negative                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Use a hash set for rows and columns to determine if each row and column contains all the numbers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Matrix / Hash Set                                                                 | M | [](https://leetcode.com/problems/valid-sudoku/)[36](https://leetcode.com/problems/valid-sudoku/)                                                                                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC36-validSudoku.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC36-validSudoku.py)                                                                                                   | Valid Sudoku                                                                | The goal isn't to solve the sudoku board, just make sure that every entry is valid. The only complicated part of the algorithm is the mapping of a cell to a 3x3 square. If it isn't immediately obvious why dividing the row/col by 3 translates to the correct row/col, I recommend trying some examples to convince yourself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Use a hash map for the rows, columns and squares of a matrix where the key is the row, column or (row, column) pair for the rows, columns and squares hash maps respectively.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Trie                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Trie / Backtracking                                                               | H | [](https://leetcode.com/problems/word-search-ii/)[212](https://leetcode.com/problems/word-search-ii/)                                                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC212-wordSearchII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC212-wordSearchII.py)                                                                                           | Word Search II                                                              | Without using a Trie, we would have to essentially run LC 79's algorithm for each word in words. But with a Trie, we only have to run a similar time complexity solution once. IMPORTANT NOTE: My solution TLEs in LeetCode. There are some optimizations that can be made to it that will make it pass the more demanding test cases. The reason I omitted these optimizations is because it takes away from being able to develop pattern recognition and this solution will 100% be accepted in an interview.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Misc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Matrix / Math                                                                     | E | [](https://leetcode.com/problems/shift-2d-grid/)[1260](https://leetcode.com/problems/shift-2d-grid/)                                                                                                                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1260-shift2DGrid.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1260-shift2DGrid.py)                                                                                                       | Shift 2D Grid                                                               | The trick for this problem is to convert every row-column to an index. This index would be the index if you traversed the array from top-left to bottom-right traversing in a left to right manner. The index is just the row number \* length of each column + the column number + k shifts. We then modulo this by (m \* n) because the index could be out of bounds, so we want to wrap it back around starting from the top-left. Getting the new row from the index is just dividing it by the number of rows, while getting the new col from the index is just moding it by n.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Concept: 1) Convert each row/column pair to an index, increment the index, then revert back to a row/column pair to shift a matrix cell's value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Matrix                                                                            | M | [](https://leetcode.com/problems/rotate-image/)[48](https://leetcode.com/problems/rotate-image/)                                                                                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC48-rotateImage.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC48-rotateImage.py)                                                                                                           | Rotate Image                                                                | Beyond the complexity of off-by-one errors and traversing the array in a spiral order correctly, a tricky part of the problem is dealing with overwriting of values. To save us from dealing with complex tmp logic, just save the top left value in a variable and start the overwriting of cells by putting the bottom left into top left, bottom right into bottom left and so on (counter-clockwise).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Rotate matrix.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Matrix                                                                            | M | [](https://leetcode.com/problems/spiral-matrix/)[54](https://leetcode.com/problems/spiral-matrix/)                                                                                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC54-spiralMatrix.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC54-spiralMatrix.py)                                                                                                         | Spiral Matrix                                                               | Use four pointers: left, right, top and bottom. Iterate from left to right, top to bottom, right to left and bottom to top. After each iteration, increment/decrement the respective pointer. After the first two for loops, we have to check if left > right or top > bottom because one of them could have crossed the other at this point.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Traversing a matrix in a spiral order.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Math                                                                              |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Prime / Composite                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Math                                                                              | E | [](https://leetcode.com/problems/ugly-number/)[263](https://leetcode.com/problems/ugly-number/)                                                                                                                                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC263-uglyNumber.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC263-uglyNumber.py)                                                                                                               | Ugly Number                                                                 | Factoring is finding numbers that multiply to get the product of a particular number. A factor of a number divides another number without a remainder. There can be multiple factors for one number. The problem isn't asking for if [2, 3, 5] are all of the factors that make up the input number, just that a subset of [2, 3, 5] are the only prime factors for the number. Prime numbers are the building blocks of other whole numbers. You can get non-prime numbers by multiplying prime numbers together. It is also worth noting that prime numbers have prime factors (themselves), so they are not ugly numbers. But 1 is an ugly number because its prime factors are limited to [2, 3, 5] (limited to does not mean it has to include these prime factors).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Composite number is a product of unique prime factors. 2) Prime numbers are a product of 1 and itself. So if we divide out the number by 5, 3 and 2 and have a number leftover that is not 1, the number is not ugly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Math                                                                              | M | [](https://leetcode.com/problems/count-primes/description/)[204](https://leetcode.com/problems/count-primes/description/)                                                                                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC204-countPrimes.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC204-countPrimes.py)                                                                                                             | Count Primes                                                                | bea                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Use Sieve of Eratosthenes to find all primes in a range of numbers. Sieve of Eratosthenes is O(N\*log(log(N)) time complexity.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Math                                                                              | M | [](https://leetcode.com/problems/smallest-value-after-replacing-with-sum-of-prime-factors/description/)[2507](https://leetcode.com/problems/smallest-value-after-replacing-with-sum-of-prime-factors/description/)                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC2507-smallestValueAfterReplacingWithSumOfPrimeFactors.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC2507-smallestValueAfterReplacingWithSumOfPrimeFactors.py)                                 | Smallest Value After Replacing With Sum of Prime Factors                    | I provided two solutions: The first being the lazy way where the algorithm iterates from 2 to n, extracting the prime factors from n. The second solution shows a bit more of an understanding on how prime factorization works in that it explicitly divides n by 2 until it isn't divisible by 2, then tries all the odd prime factors >= 3 up to sqrt(n).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Concept: 1) All natural numbers greater than 1 can be written as a product of prime numbers (prime factorization). 2) Prime factorization algorithm to find all prime factors in sqrt(n) time instead of n: divide by 2 until not divisible by 2, then divide by odd numbers starting from 3 up to sqrt(n). The remaining number, if it is greater than 2, will be a prime number. The reason it can only be one number is because if we have two prime numbers > sqrt(n), the two prime numbers multiplied would be > n.                                                                                                                                                                                                                                                                      |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Combinatorics                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Strictly for calculating combinations and permutations.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Math / Prime Numbers                                                              | M | [](https://leetcode.com/problems/prime-arrangements/description/)[1175](https://leetcode.com/problems/prime-arrangements/description/)                                                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC1175-primeArrangements.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC1175-primeArrangements.py)                                                                                               | Prime Arrangements                                                          | Firstly we have to understand what arrangements/permutations means. This means the number of different arrangements the digits can take on (order matters unlike combinations). Next we have to understand that we don't only care about permutations of prime numbers in this problem. Permutations of composite numbers also have to be taken into account because they can be rearranged too. So we can get the number of prime numbers, subtract n by the number of prime numbers to get the number of composite numbers, calculate the factorial of both (which represents the number of permutations/arrangements these values can represent), and multiply these two numbers using the product rule for counting to get the result.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Use Sieve of Eratosthenes to find all primes in a range of numbers. 2) Permutations. 2) Combinations. 3) Use factorial(n) to count the number of possible arrangements of n elements and the product rule of counting to count the number of possible arrangements of two sets of elements. This is why we do fact(composite number count) \* fact(prime number count). To think about the product rule for counting, think about the combination (not permutation because combination is easier to visualize this rule) application using a combination lock: 0-9 choices for first position, 0-9 choices for second position. This is 10 \* 10 = 100 combinations. For permutations, we are multiplying fact() \* fact() because there are two sets of numbers we are permuting. |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Factor / Divisor                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Factor of a number is a number that divides another number without a remainder. A divisor is a number that divides another number and may or may not have a remainder. A multiple is a number that is the product of two numbers that are multiplied together.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Math                                                                              | E | [](https://leetcode.com/problems/number-of-common-factors/description/)[2427](https://leetcode.com/problems/number-of-common-factors/description/)                                                                                                       |                                                                                                                                                                                                                                                                                      | Number of Common Factors                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Common factors between two numbers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Math                                                                      | E | [](https://leetcode.com/problems/find-greatest-common-divisor-of-array/description/)[1979](https://leetcode.com/problems/find-greatest-common-divisor-of-array/description/)                                                                             |                                                                                                                                                                                                                                                                                      | Find Greatest Common Divisor of Array                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: Get GCD across multiple numbers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Process Digits                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Process each digit of a number using mathematical operations instead of casting to a string and iterating through each digit.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Array / Math                                                                      | E | [](https://leetcode.com/problems/palindrome-number/)[9](https://leetcode.com/problems/palindrome-number/)                                                                                                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC9-palindromeNumber.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC9-palindromeNumber.py)                                                                                                       | Palindrome Number                                                           | The difficulty with this problem is with implementing the idea of using two pointers to traverse a linear collection of elements, but instead on an integer that you cannot easily index into. We need to get the left and right digits at each iteration and then remove them from the number. To get the left number, start with the last multiple of 10 that is less than n and divide it by 100 at each iteration (since we are removing two digits). To get the right number, always mod the number by 10.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Process an integer by getting the first and last digit at each iteration without casting the integer to a string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Math                                                                              | E | [](https://leetcode.com/problems/alternating-digit-sum/)[2544](https://leetcode.com/problems/alternating-digit-sum/)                                                                                                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC2544-alternatingDigitSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC2544-alternatingDigitSum.py)                                                                                           | Alternating Digit Sum                                                       | This is similar to other problems where we want to take a digit off of an integer one at a time. Taking digits from the right is fairly trivial as we only have to mod the number by 10 and then divide it by 10. But taking from the left is a bit different. We must first find the largest multiple of 10 less than the number. Dividing the number by this divisor will give us the left digit. Then to get rid of that digit, we subtract the number by the multiplication of the digit by the divisor. So if we have the number 523 and a divisor of 100, we are subtracting 500 to get 23. Then we divide the divisor by 10 for the next iteration.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Process digits from left to right (most significant digit first, so need to use a div variable).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Long Addition                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Math                                                                      | E | [](https://leetcode.com/problems/plus-one/)[66](https://leetcode.com/problems/plus-one/)                                                                                                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC66-plusOne.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC66-plusOne.py)                                                                                                                       | Plus One                                                                    | This is a common pattern with manual addition of integers. It's essentially long addition. We use a carry variable to carry to the next position. To calculate the current place's digit, we add the current digit and carry together. Then if this new digit is greater than 10, we get a new carry from new_digit // 10 and we update new_digit by modding it by 10. The carry can extend beyond the original digit indices, so we have to remember to add it if a carry exists at the end. If we consider the output array to not be a part of the space copmlexity, then it is O(1) space.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Add two numbers where one number is a single digit using long addition.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Array / Math                                                                      | E | [](https://leetcode.com/problems/add-to-array-form-of-integer/description/)[989](https://leetcode.com/problems/add-to-array-form-of-integer/description/)                                                                                                |                                                                                                                                                                                                                                                                                      | Add to Array-Form of Integer                                                | This is more complex than LC 66 because you have to traverse two numbers digit-by-digit to add them together instead of just adding one number to the least significant digit.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Add two numbers that can have multiple digits together using long addition.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Modulo                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Math                                                                      | M | [](https://leetcode.com/problems/find-the-student-that-will-replace-the-chalk/description/)[1894](https://leetcode.com/problems/find-the-student-that-will-replace-the-chalk/description/)                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC1894-findTheStudentThatWillReplaceTheChalk.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Math/LC1894-findTheStudentThatWillReplaceTheChalk.py)                                                       | Find the Student that Will Replace the Chalk                                | K can be as high as 10\*\*9, which is a billion. We could have a situation where the array is just 1's, so we would be doing 1 billion iterations. We only care about what index in the chalk array that crosses 0. So we can skip all of the iterations through the chalk array until the last iteration that has an index that makes k cross 0. To do this, we get the sum of the chalk array and modulo k by it. (Remove sum by k as long as k is greater than or equal to sum, then when/if k is less than sum, this is our remainder. So we iterate from 0, subtracting from k until k crosses 0).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) If subtracting sum of an array's values multiple times, can modulo target by the array sum and start iterating from beginning to find index that reaches target.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Misc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Math                                                                              | E | [](https://leetcode.com/problems/check-if-it-is-a-straight-line/description/)[1232](https://leetcode.com/problems/check-if-it-is-a-straight-line/description/)                                                                                           |                                                                                                                                                                                                                                                                                      | Check If It Is a Straight Line                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Slope of a line.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Array / Math                                                                      | E | [](https://leetcode.com/problems/missing-number/)[268](https://leetcode.com/problems/missing-number/)                                                                                                                                                    |                                                                                                                                                                                                                                                                                      | Missing Number                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Arithmetic progression.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Cartesian Grid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Math                                                                              | E | [](https://leetcode.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/)[1779](https://leetcode.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/)                                                                   |                                                                                                                                                                                                                                                                                      | Find Nearest Point That Has the Same X or Y Coordinate                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Cartesian grid. 2) Manhattan distance.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Math                                                                              | E | [](https://leetcode.com/problems/minimum-time-visiting-all-points/description/)[1266](https://leetcode.com/problems/minimum-time-visiting-all-points/description/)                                                                                       |                                                                                                                                                                                                                                                                                      | Minimum Time Visiting All Points                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Cartesian grid. 2) Minimum travel distance between points using straight or diagonal movements. 3) Euclidean distance.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Greedy                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Math / Greedy                                                                     | M | [](https://leetcode.com/problems/minimum-moves-to-reach-target-score/description/)[2139](https://leetcode.com/problems/minimum-moves-to-reach-target-score/description/)                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Greedy/LC2139-minimumMovesToReachTargetScore.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Greedy/LC2139-minimumMovesToReachTargetScore.py)                                                                 | Minimum Moves to Reach Target Score                                         | Flip the thinking from going from 1 to target to target to 1. We use this new thinking because we want to greedily get the most out of each double move. We can decide to divide by 2 or subtract by 1 based on if the current value is even. This assures the current decision is valid. Then we can iterate until the current number is not 1, using three cases: if we still have double moves left AND the current number is even, we can divide by 2. Elif we don't have double moves left, this means we only have single moves, so we can just add the current number - 1 moves to moves and stop iterating. Else, we still have double moves left to use but we aren't at an even number, so use a single move.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) To greedily choose between multiplying by 2 or adding 1 at each step to minimize the number of steps to get to a target value from 1 we must flip our thinking to instead go to 1 from the target value so we can greedily pick multiplication (in this case division) by 2 at the most significant choice (higher number = more distance covered with division).                                                                                                                                                                                                                                                                                                                                                                                                                  |
| String                                                                            |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Parse Pattern                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Use one or two pointers to traverse a string to parse it/match some pattern. Can be used to find multiple substrings/subarrays or just one. These types of problems are GUARANTEED to have a searchable ending position if the starting position is found (example: when left parenthesis is found, iterate until right parenthesis is found).                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| String / Hash Map / Two Pointers                                                  | M | [](https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/description/)[1807](https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/description/)                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC1807-evaluateTheBracketPairsOfAString.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC1807-evaluateTheBracketPairsOfAString.py)                                             | Evaluate the Bracket Pairs of a String                                      | This is a common subpattern of strings where you need to find the indices of the starting and ending position of a substrings that follow a certain pattern within a string. Two other problems with the same approach: LC 1410 - HTML Entity Parser and LC 271 - Encode and Decode Strings.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Concept: 1) Hash map to map string to string. 2) Finding substrings that follow a certain pattern using two pointers. 3) Build string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| String / Two Pointers                                                             | M | [](https://leetcode.com/problems/count-and-say/)[38](https://leetcode.com/problems/count-and-say/)                                                                                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC38-countAndSay.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC38-countAndSay.py)                                                                                           | Count and Say                                                               | To get each part of the new number, i.e. "two 3's", just use a left and right pointer, incrementing the right pointer while the value at the left pointer == the value at the right pointer. Then this part of the new number is the length + the value. We use an array to build the string because string building with an array is O(N) time, whereas string building with a string concatenation is O(N^2).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use two pointers to traverse a string and process each grouping of characters.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Search for Substring                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Brute-force double for loop or optimal KMP.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                                                                   | E | [](https://leetcode.com/problems/number-of-strings-that-appear-as-substrings-in-word/description/)[1967](https://leetcode.com/problems/number-of-strings-that-appear-as-substrings-in-word/description/)                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC1967-numberOfStringsThatAppearAsSubstringsInWord.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC1967-numberOfStringsThatAppearAsSubstringsInWord.py)                                         | Number of Strings That Appear as Substrings in Word                         | In python we can do "if x in y" to find if a string is a subtring of another string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Concept: 1) Determine if a substring exists in a string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                                                                   | M | [](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/)[28](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/)                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC28-findTheIndexOfTheFirstOccurrenceInAString.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC28-findTheIndexOfTheFirstOccurrenceInAString.py)                                               | Find the Index of First Occurrence in a String                              | KMP is the optimal algorithm for this problem, but no way am I going to learn that. Just do a double for loop checking each substring.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: Find substring inside of a string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Two Pointers                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Determine if one string/array is a subequence of another string/array. It is important to note that checking for substring/subarray is not the same as checking for subsequence.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                                                                   | E | [](https://leetcode.com/problems/is-subsequence/)[392](https://leetcode.com/problems/is-subsequence/)                                                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC392-isSubsequence.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC392-isSubsequence.py)                                                                                     | Is Subsequence                                                              | Since we are only looking to match a singular subsequence, it is sufficient to greedily search for matching characters between both strings with a single linear traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Determine if a string is a subsequence of another string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                                                                   | M | [](https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/)[524](https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/)                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC524-longestWordInDictionaryThroughDeleting.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC524-longestWordInDictionaryThroughDeleting.py)                                                   | Longest Word in Dictionary through Deleting                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Check if a string is a subsequence of another string. 2) Get the lexographically smallest substring that is the maximum length.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| String / Two Pointers                                                             | E | [](https://leetcode.com/problems/merge-strings-alternately/description/)[1768](https://leetcode.com/problems/merge-strings-alternately/description/)                                                                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC1768-mergeStringsAlternately.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC1768-mergeStringsAlternately.py)                                                                               | Merge Strings Alternately                                                   | This is an important problem to understand that string concatenation cannot be done in O(1) time. Strings are immutable in Python, so under the hood, Python is creating a new copy of the string every time a concatenation is performed, even if only 1 character is being concatenated to the end of a string. So N concatenations to a string is O(N^2) time. To avoid this copying, we instead build up a list of characters, then use Python's build-in join() method for strings to build a string from an array of characters. This changes the time complexity of the solution from O((M+N)^2) to O(M+N).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Building a string. 2) Two pointers to traverse two strings simultaneously.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| String / Two Pointers                                                             | E | [](https://leetcode.com/problems/reverse-string/)[344](https://leetcode.com/problems/reverse-string/)                                                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC344-reverseString.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC344-reverseString.py)                                                                                     | Reverse String                                                              | The two pointer technique is an improvement on having to use extra space to reverse the string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Reverse a string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| String / Two Pointers                                                             | E | [](https://leetcode.com/problems/valid-palindrome/)[125](https://leetcode.com/problems/valid-palindrome/)                                                                                                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC125-validPalindrome.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC125-validPalindrome.py)                                                                                 | Valid Palindrome                                                            | This is a classic two-pointer palindrome problem with a twist of having alphanumericals and non-alphanumericals. It has a lot of dislikes because it wants you to skip non-alphanumericals, which makes it feel less like a true palindrome and might be a bit less intuitive. But if you think of it as just checking if the letters and numbers in the string are palindromic, it makes more sense.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Check if a string is a palindrome.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| String                                                                            | M | [](https://leetcode.com/problems/longest-palindromic-substring/)[5](https://leetcode.com/problems/longest-palindromic-substring/)                                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC5-longestPalindromicSubstring.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC5-longestPalindromicSubstring.py)                                                                             | Longest Palindromic Substring                                               | The naïve approach is to compute all of the substrings and do a palindrome check on each (O(N^3) time). An improvement on this is doing a linear scan of the string and assume the index of each character is the middle of a palindrome. Then expand outwards as long as the edges of the palindrome are equal. This is O(N^2) time. We need to make sure to check the odd length AND even length palindromes, so for the odd length palindromes we start our palindrome checking i, i. And for the even length palindromes we start our palindrome checking t i, i + 1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Count the number of palindromic substrings by using expansion from middle technique. 2) Difference between even-length and odd-length palindromes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Pivot Partition                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | A subset of prefix/postfix sum problems where you partition the string by a pivot and update the prefix/postfix information at each pivot index.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| String                                                                            | M | [](https://leetcode.com/problems/number-of-good-ways-to-split-a-string/description/)[1525](https://leetcode.com/problems/number-of-good-ways-to-split-a-string/description/)                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC1525-numberOfGoodWaysToSplitAString.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC1525-numberOfGoodWaysToSplitAString.py)                                                                 | Number of Good Ways to Split a String                                       | This is a problem pattern where you start the value of the right side of the array (number of distinct letters) by getting the number of distinct letters of the entire string. Then we iterate through the string, removing from right and adding to left, then checking the condition. The important distinction between this problem and other types of these problems is the pivot is inclusive, meaning we want to include it in the letters for the left side before we check if len(ld) == len(rd). Similar problems to this include: LC 2485 - Find the Pivot Integer, LC 2155 - All Divisions With the Highest Score of a Binary Array, LC 724 - Find Pivot Index, LC 1991 - Find the Middle Index in Array (duplicate problem of LC 724 with different wording).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Pivot index and comparing some value of the right side of the pivot and left side of the pivot and doing this for every index in the array. Start the right side with all array values considered and remove from it while adding to the left side so we can avoid repeated work.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| String / Hash Set                                                                 | M | [](https://leetcode.com/problems/unique-length-3-palindromic-subsequences/)[1930](https://leetcode.com/problems/unique-length-3-palindromic-subsequences/)                                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1930-uniqueLength-3PalindromicSubsequences.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1930-uniqueLength-3PalindromicSubsequences.py)                                           | Unique Length-3 Palindromic Subsequences                                    | For every length-3 palindrome, the outer 2 characters must be the same and the inner character can be anything. This is why we maintain data structures that allow us to know, in constant time, what is to the left and to the right of the current char we are trying to create a length-3 palindrome with. We use a set on the left because it doesn't matter what the count is, whereas it does matter what the count is on the right because we are taking away from the characters on that side, so a character could and will go down to a frequency of 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) Using a set for left portion of string and hash map of right portion of string to look up characters in constant time. 2) Checking if a character exists on both sides is as simple as looping through all possible characters (or on of the hash set/hash map).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Breadth-First Search                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| String / BFS                                                                      | M | [](https://leetcode.com/problems/open-the-lock/)[752](https://leetcode.com/problems/open-the-lock/)                                                                                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph%20Traversal/LC752-openTheLock.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph%20Traversal/LC752-openTheLock.py)                                                                                   | Open the Lock                                                               | One good improvement for this problem is relegating the work to generate neighboring lock combination states to a helper function. For time/space complexity analysis, there are 10 \* 10 \* 10 \* 10 possible combinations which is 10^N where N is the number of lock positions. For each combination, we are looping N times and building up the string which takes N time, so N^2 time. The reason we can simply use a turns variable and increment it at each BFS iteration is because this BFS can be thought of as a BFS on an unweighted graph. It is considered unweighted (its actually a constant weight of 1, which can be considered the same as unweighted) because no matter which path you choose, it always costs a distance of 1. So no matter what lock combination you choose at each level, it will always cost 1 more in distance/weight than the previous level. So when we reach our target combination, the number of levels is guaranteed to be the shortest path to the target combination since it is the first time the target has been seen.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Breadth-First Search on a string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| String / BFS / Hash Set / Shortest Path                                           | H | [](https://leetcode.com/problems/word-ladder/)[127](https://leetcode.com/problems/word-ladder/)                                                                                                                                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC127-wordLadder.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC127-wordLadder.py)                                                                                                           | Word Ladder                                                                 | We have words that are essentially nodes and edges between words which is the change by 1 letter. We have a source and are trying to find a destination. We are trying to find the shortest path between the source and destination. We add all possibilities from source, then add all possibilities of those possiblities etc. This is an unweighted SSSP problem, so BFS fits the criteria. We delete words from the set because the shortest path will never traverse the same word twice.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) BFS on a starting word with the goal of transforming it to an ending word (in the shortest amount of steps possible).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| String / BFS                                                                      | H | [](https://leetcode.com/problems/k-similar-strings/description/)[854](https://leetcode.com/problems/k-similar-strings/description/)                                                                                                                      |                                                                                                                                                                                                                                                                                      | K-Similar Strings                                                           | [](https://leetcode.com/problems/word-ladder-ii/solutions/352661/simple-python-bfs-solution-similar-problems-listed/)[https://leetcode.com/problems/word-ladder-ii/solutions/352661/simple-python-bfs-solution-similar-problems-listed/](https://leetcode.com/problems/word-ladder-ii/solutions/352661/simple-python-bfs-solution-similar-problems-listed/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) BFS on a string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Misc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| String                                                                            | E | [](https://leetcode.com/problems/greatest-common-divisor-of-strings/description/)[1071](https://leetcode.com/problems/greatest-common-divisor-of-strings/description/)                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC1071-greatestCommonDivisorOfStrings.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC1071-greatestCommonDivisorOfStrings.py)                                                                 | Greatest Common Divisor of Strings                                          | The upper bound for the string lengths is 1000, so O(N^2) or better is our target time complexity. For this solution, we check every substring and see if it divides the string. If it does divide it, we add it to a hash set. Then we do the same substring check for the second string, but if we come across a substring that is already in the hash map, we can compare the length to the current max length found and update the max length string if it is larger.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Greatest common divisor substring between two strings.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| String                                                                            | M | [](https://leetcode.com/problems/find-and-replace-pattern/)[890](https://leetcode.com/problems/find-and-replace-pattern/)                                                                                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC890-findAndReplacePattern.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC890-findAndReplacePattern.py)                                                                                     | Find and Replace Pattern                                                    | This is essentially the same problem as LC 205 - "Isomorphic Strings". The idea is to check if there is a bijection between two strings. The only difference is we need to check if the pattern is isomorphic with each word, and if they are, append each isomorphic complement to the pattern string to the result array. To do this in a clean manner, we can use a helper function 'is_bijection(w1, w2) which takes in the pattern and the current word we are checking. For the time complexity, N is the number of words and K is the length of each word.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) Isomorphic strings/bijection.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Prefix / Suffix                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| String                                                                            | E | [](https://leetcode.com/problems/counting-words-with-a-given-prefix/description/)[2185](https://leetcode.com/problems/counting-words-with-a-given-prefix/description/)                                                                                   |                                                                                                                                                                                                                                                                                      | Counting Words With a Given Prefix                                          | Good easy problem to be introduced to prefix strings.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Prefix string. 2) Compare strings.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| String                                                                            | M | [](https://leetcode.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/)[2023](https://leetcode.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/)                                                     |                                                                                                                                                                                                                                                                                      | Number of Pairs of Strings With Concatenation Equal to Target               | A big aspect of this problem is understanding how to count the amount of permutations of each pair there can be.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Prefix and suffix strings. 2) Pair permutations (there are 2 permutations that can be made out of two elements unless they're the same, then only one).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Hash Map                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| String / Hash Map                                                                 | E | [](https://leetcode.com/problems/rearrange-characters-to-make-target-string/description/)[2287](https://leetcode.com/problems/rearrange-characters-to-make-target-string/description/)                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2395-findSubarraysWithEqualSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2395-findSubarraysWithEqualSum.py)                                                       | Rearrange Characters to Make Target String                                  | This is a problem where we have to find the counts of each character in the target string, and see how many times we can extract each character of their respective frequency from the string. So if we have 2 'b' characters in the target string, and 4 'b' characters in the original string, we have enough characters in the original string to make 2 of the target strings. The minimum of all these calculations across every unique character in the target string is the maximum copies of target we can make.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Concept: 1) Use a count hash map to get the number of instances a string that can be formed from our source string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| String / Hash Map                                                                 | E | [](https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/)[1160](https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/)                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1160-findWordsThatCanBeFormedByCharacters.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1160-findWordsThatCanBeFormedByCharacters.py)                                             | Find Words That Can Be Formed by Characters                                 | This is a good problem to implement Python's for-else logic to avoid using a flag variable. So we use a hash map for the counts of each char in chars. Then get the count of each char for each word. If any of the characters in the word are of higher frequency than what is available in the chars hash map, we can break. If this break statement is never executed, the execution falls into the else block, which is where we can increment res since every char in the word met the criteria.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Use a hash map to store the frequency of each character in a source string. 2) ompare the frequency of each character in a target string to see if there are enough characters to make the target string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| String / Hash Map                                                                 | E | [](https://leetcode.com/problems/longest-palindrome/)[409](https://leetcode.com/problems/longest-palindrome/)                                                                                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC409-longestPalindrome.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC409-longestPalindrome.py)                                                                                             | Longest Palindrome                                                          | For this problem, a palindrome can be BUILT from letters, so you can choose any permutation of the letters. This is different than finding the longest palindrome of a static string that cannot be rearranged. The brute-force would be to check every possible permutation of the letters and then find the longest palindrome of each permutation. This is highly inefficient. To get it to linear time complexity, we can just greedily add pairs of 2 of the same char. This is where getting the counts becomes useful.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Use counts of each character in a string to build a palindromic string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| String / Hash Map                                                                 | M | [](https://leetcode.com/problems/construct-k-palindrome-strings/description/)[1400](https://leetcode.com/problems/construct-k-palindrome-strings/description/)                                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1400-constructKPalindromeStrings.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1400-constructKPalindromeStrings.py)                                                               | Construct K Palindrome Strings                                              | Really good question to test knowledge of how palindromes can be constructed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) The relationship between odd character counts and how many palindromes can be made out of a string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| String / Hash Map                                                                 | E | [](https://leetcode.com/problems/redistribute-characters-to-make-all-strings-equal/description/)[1897](https://leetcode.com/problems/redistribute-characters-to-make-all-strings-equal/description/)                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1897-redistributeCharactersToMakeAllStringsEqual.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1897-redistributeCharactersToMakeAllStringsEqual.py)                               | Redistribute Characters to Make All Strings Equal                           | Since we can do an infinite amount of swaps from any word to any other word, this means that all we have to check is if there are enough chars to equally spread across every word for each unique char. This is why we just count the number of chars and make sure their respective counts are all divisible by n, the length of the input words list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Concept: 1) Use a hash map to store the frequency of each character across a series of words. Each frequency being divisible by the number of words will determine if all strings words can be rearranged to be equal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| String / Hash Map                                                                 | M | [](https://leetcode.com/problems/determine-if-two-strings-are-close/description/)[1657](https://leetcode.com/problems/determine-if-two-strings-are-close/description/)                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1657-determineIfTwoStringsAreClose.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1657-determineIfTwoStringsAreClose.py)                                                           | Determine if Two Strings Are Close                                          | Since operation 1 allows us to swap any characters, order doesn't matter. So we are only interested in two things: the unique characters and the counts of each unique character. The first check is if the unique characters are equal, while the second check is if the SORTED counts of each character between both words are equal. This works because if the counts of a character are different, we need to swap the character count with another character. This is only possible across all characters if the counts are equal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Use character counts and sorting the counts to check if the characters can be rearranged to equal the same strings.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| String / Hash Map                                                                 | E | [](https://leetcode.com/problems/valid-anagram/)[242](https://leetcode.com/problems/valid-anagram/)                                                                                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC242-validAnagram.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC242-validAnagram.py)                                                                                               | Valid Anagram                                                               | Since order does not matter, the brute-force approach would be to sort both strings and compare them character by character. Which is O(2Nlog(N) + N). So the hash map solution is an improvement by not having to sort the input strings.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Use hash maps for character counts to check if two strings are anagrams.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| String / Hash Map                                                                 | M | [](https://leetcode.com/problems/group-anagrams/)[59](https://leetcode.com/problems/group-anagrams/)                                                                                                                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC49-groupAnagrams.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC49-groupAnagrams.py)                                                                                               | Group Anagrams                                                              | Anagrams are identified by their character count of each character since the order of characters does not matter. We can use this information to form our approach. We opt to use a hash map of lists where the key is a frequency array of each string's characters casted to a tuple and the lists consist of the corresponding original string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Use a hash map with a key of a tuple of character counts from a-z and a value of a list that stores the string. 2) Cast characters of a string to integers to map a 0 through 25 index array to frequencies of characters in a string. Then use this casted to a tuple as a hashable key that maps to the original string.                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| String                                                                            | M | [](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/)[1347](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/)                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC1347-minimumNumberOfStepsToMakeTwoStringsAnagram.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC1347-minimumNumberOfStepsToMakeTwoStringsAnagram.py)                                       | Minimum Number of Steps to Make Two Strings Anagram                         | An initial approach I tried was to have two char count dictionaries and sum up the absolute differences between the count of each char in s to t. Why doesn't this work? Consider the case s = "bab" and t = "aba". Taking differences of each character gives us a result of 2. But if we just change one of the a's to b, we get our anagram. So what went wrong? With this approach, we are counting surplus chars in t as well as the char we need more of. This is a double count because surplus can be decreased in the same step as adding a char to get to the desired count. This is why we do the counting method and ignore chars that are negative in the array (have a surplus).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Relationship between two strings based on how close they are to being anagrams. 2) Ignore characters that are in surplus in original string and instead count characters that are needed to make target string to avoid double counting.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Hash Set                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| String / Hash Set                                                                 | E | [](https://leetcode.com/problems/maximum-number-of-words-you-can-type/description/)[1935](https://leetcode.com/problems/maximum-number-of-words-you-can-type/description/)                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1935-maximumNumberOfWordsYouCanType.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1935-maximumNumberOfWordsYouCanType.py)                                                         | Maximum Number of Words You Can Type                                        | Cast brokenLetters to a hash set so we can look up the broken letters in O(1) time. Then iterate through the words, and iterate through each char in each word. If a char is in the broken set, we break. If the for loop finishes without breaking, we fall into the else statement in the if-else conditional and can increment count by 1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Use a hash set to store characters and then use this hash set to check in O(1) time if a character in a string is present in the set of words.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| String / Hash Set                                                                 | E | [](https://leetcode.com/problems/count-the-number-of-consistent-strings/description/)[1684](https://leetcode.com/problems/count-the-number-of-consistent-strings/description/)                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1684-countTheNumberOfConsistentStrings.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1684-countTheNumberOfConsistentStrings.py)                                                   | Count the Number of Consistent Strings                                      | Cast the string "allowed" to a set. This adds each unique letter in allowed to the set. Then we can iterate through each char in each word. If the entire word is traversed, we fall into the else starement in the for-else conditional. Otherwise, we break out of the loop without adding to res.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Concept: 1) Use a hash set to store characters that we can use to check in O(1) time if a character is in the set.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Ordinal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Hash Set                                                                          | E | [](https://leetcode.com/problems/greatest-english-letter-in-upper-and-lower-case/description/)[2309](https://leetcode.com/problems/greatest-english-letter-in-upper-and-lower-case/description/)                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2309-greatestEnglishLetterInUpperAndLowerCase.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2309-greatestEnglishLetterInUpperAndLowerCase.py)                                     | Greatest English Letter in Upper and Lower Case                             | The ordinal values for the corresponding characters in the English alphabet are not 0-52 for lowercase and uppercase alphabet like I assumed. So instead, we can get each ordinal value by using the upper bounds of the ordinal value range with upper = ord('Z') and lower = ord('z'). Then we can iterate backwards from 26 and the first chr(upper-i) and chr(lower-i) pair we see in the char_set, we return the upper character.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Use a hash set to check if characters are in a string. 2) Use ord('Z') and ord('z') to efficiently get the character of a-z and A-Z using subtraction of character index (0 through 25).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| String                                                                            | M | [](https://leetcode.com/problems/shifting-letters/description/)[848](https://leetcode.com/problems/shifting-letters/description/)                                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC848-shiftingLetters.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC848-shiftingLetters.py)                                                                                                 | Shifting Letters                                                            | Each char starting from the left shifts the sum of all shifts to the right of it. So instead of taking O(N^2) time to shift all characters up to the index i at each iteration, we can precomupte the total shifts first. To do this, we can start from the right side and the acummulated sum to each index including the value at the index will the the number of shifts for the index. Then we can do a linear scran from left to right to shift the char using ord and modulo logic.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Convert character to ordinal value. 2) Shifting a character in the alphabet (same idea as shifting an element in an array). 3) Suffix sum.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Trie                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Trie / String                                                                     | E | [](https://leetcode.com/problems/longest-common-prefix/)[14](https://leetcode.com/problems/longest-common-prefix/)                                                                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/String/LC14-longestCommonPrefix.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC14-longestCommonPrefix.py)                                                                                           | Longest Common Prefix                                                       | This specific problem can be solved in O(N^2) time because of the constraint, but LCP is a fundamental idea for Trie, so we use Trie here.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: Longest common prefix between an array for strings.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Trie                                                                              | M | [](https://leetcode.com/problems/implement-trie-prefix-tree/)[208](https://leetcode.com/problems/implement-trie-prefix-tree/)                                                                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Trie/LC208-implementTrie.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Trie/LC208-implementTrie.py)                                                                                                         | Implement Trie (Prefix Tree)                                                | The main benefit to a Trie is through searching because we are able to search for prefixes of words. Checking if a word exists in a data structure would be easy with a simple hash map, but checking if a prefix exists in a list of words is much harder and cannot be trivially done with a hash map. For time complexity, O(L) is for search/insert/startsWith where L is the length of the input word/prefix. For space complexity, O(L\*N) is for the total number of nodes in the Trie. L is the average length of a word and N is the number of words. We are bound by 26 nodes per level, but every word can theoretically differ in letter sequence, so it is not sufficient enough to say O(L\*26).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Trie.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Trie / Hash Set                                                                   | M | [](https://leetcode.com/problems/replace-words/description/)[648](https://leetcode.com/problems/replace-words/description/)                                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Trie/LC648-replaceWords.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Trie/LC648-replaceWords.py)                                                                                                           | Replace Words                                                               | The problem with the brute-force approach of checking every prefix is we have to hash every prefix, so this takes W^2 time for every word. Searching based on prefixes of words is a type of problem that is exactly what Tries are good for, so we will use a Trie to improve the time complexity.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Trie. 2) Identify if each word in a sentence has a prefix in the trie.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Trie                                                                              | H | [](https://leetcode.com/problems/sum-of-prefix-scores-of-strings/description/)[2416](https://leetcode.com/problems/sum-of-prefix-scores-of-strings/description/)                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Trie/LC2416-sumOfPrefixScoresOfStrings.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Trie/LC2416-sumOfPrefixScoresOfStrings.py)                                                                             | Sum of Prefix Scores of Strings                                             | We want to have access to the prefixes of all words in the words list at each iteration. This tells us we are probably going to use a Trie. The slight added complexity to this problem is we have to count the number of words that match the prefix, not just that a prefix exists like many Trie problems. To do this, we just add a "count" member variable to the TrieNode class. When we are building the Trie, we increment the count by 1 every time we visit this node. This signifies the amount of times this character is present in this position in the prefix. Then we can use this count during the iteration through each prefix for each word in words to add to a global count which will be the score.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Trie. 2) Store an extra count variable in each trie node that counts the numbe of prefix paths that pass through this node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Trie                                                                              | M | [](https://leetcode.com/problems/search-suggestions-system/)[1268](https://leetcode.com/problems/search-suggestions-system/)                                                                                                                             |                                                                                                                                                                                                                                                                                      | Search Suggestions System                                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Trie. 2) Store an extra array variable in each trie node that stores the words that traverse this node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Greedy                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Greedy / String                                                                   | M | [](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/description/)[1647](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/description/)                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Greedy/LC1647-minimumDeletionsToMakeCharacterFrequenciesUnique.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Greedy/LC1647-minimumDeletionsToMakeCharacterFrequenciesUnique.py)                             | Minimum Deletions to Make Character Frequencies Unique                      | If you've done a decent amount of greedy problems, this problem description should make it pretty obvious that a greedy algorithm is something you should try. When we are trying to minimize the operations to make adjacent numbers not equal to each other, sorting + greedily choose the closest number that satisfies the constraint and minimizes the result. This is a very similar problem to LC 945: Minimum Increment to Make Array Unique.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) To minimize operations to make adjacent values not equal each other, sort and greedily choose the closest number that satisfies the constraint, thus minimizing the number of operations.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| String / Greedy                                                                   | M | [](https://leetcode.com/problems/check-if-a-string-can-break-another-string/description/)[1443](https://leetcode.com/problems/check-if-a-string-can-break-another-string/description/)                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Greedy/LC1433-checkIfAStringCanBreakAnotherString.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Greedy/LC1433-checkIfAStringCanBreakAnotherString.py)                                                       | Check If a String Can Break Another String                                  | The thought process behind the greedy approach goes as follows: We want to make s1 either greater than s2 at each character, or less than s2 at each character. We have a constraint of 10^5, so we need something in O(N) time or O(Nlog(N)). When comparing between two collections of elements, sorting comes to mind. But how can it fit this problem? Think of what we're trying to achieve again. Strings with each character either <= or >= than the other string's character at each position. If both are sorted, the first comparison will be our desired comparison. If s1[0] >= s2[0] for example, we want all other comparisons to be this. Because the strings are sorted, it is the optimal chance for each position to follow the original comparison.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Sort two strings by lexographical ordering to check if we can rearrange the characters in one of the strings such that each character in one string is greater than the character in the same position in the second string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Stack                                                                             |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Consecutive Removals                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Stack                                                                             | M | [](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)[1209](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC1209-removeAllAdjacentDuplicatesInStringII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC1209-removeAllAdjacentDuplicatesInStringII.py)                                                     | Remove All Adjacent Duplicates in String II                                 | When a problem has a linear collection of elements, where a condition is checked for contiguous elements, and those elements can be removed, and deletions of contiguous elements can be applied more than once, this is a stack problem. We use a stack because it is way more efficient than something like string concatenation/slicing.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Deleting contiguous elements from a linear collection of elements (elements collapse after deletion so there could be more contiguous sequences of elements formed). 2) Encoding count in stack.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Stack                                                                             | M | [](https://leetcode.com/problems/removing-stars-from-a-string/description/)[2390](https://leetcode.com/problems/removing-stars-from-a-string/description/)                                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC2390-removingStarsFromAString.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC2390-removingStarsFromAString.py)                                                                               | Removing Stars From a String                                                | If we see a star, we pop from the stack, otherwise we append to the stack. Then just use the string join method to join the stack into a string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Remove an element to the left of a special character.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Stack / String                                                                    | M | [](https://leetcode.com/problems/remove-all-occurrences-of-a-substring/description/)[1910](https://leetcode.com/problems/remove-all-occurrences-of-a-substring/description/)                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC1910-removeAllOccurrencesOfASubstring.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC1910-removeAllOccurrencesOfASubstring.py)                                                               | Remove All Occurrences of a Substring                                       | Simple stack problem where we check top of stack and pop substring if it matches the target substring.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Removing a pattern repeatedly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Valid Parentheses                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Problems that require checking the balance of parentheses, braces or brackets in an expression.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Stack / Hash Map                                                                  | E | [](https://leetcode.com/problems/valid-parentheses/)[20](https://leetcode.com/problems/valid-parentheses/)                                                                                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC20-validParentheses.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC20-validParentheses.py)                                                                                                   | Valid Parentheses                                                           | We use a close to open map instead of an open to close map because we have to compare a seen close bracket to the matching open bracket easily. For open brackets, we just append to the stack and don't need to find a match.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Use a hash map to map each closing parenthesis to its respective opening parenthesis. 2) Check if a sequence of parentheses is valid.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Stack                                                                             | M | [](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/description/)[921](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/description/)                                                                              |                                                                                                                                                                                                                                                                                      | Minimum Add to Make Parentheses Valid                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Check how many parentheses need to be added to make the parentheses valid.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Stack                                                                             | H | [](https://leetcode.com/problems/longest-valid-parentheses/)[32](https://leetcode.com/problems/longest-valid-parentheses/)                                                                                                                               |                                                                                                                                                                                                                                                                                      | Longest Valid Parentheses                                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Longest valid parentheses substring of a parentheses string. 2) Use a stack of indices to have access to the last opening parenthesis that would make this substring valid.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Nesting                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Stack                                                                             | M | [](https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/description/)[1190](https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/description/)                                                 |                                                                                                                                                                                                                                                                                      | Reverse Substrings Between Each Pair of Parentheses                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Building substrings in a stack.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Stack                                                                             | M | [](https://leetcode.com/problems/decode-string/)[394](https://leetcode.com/problems/decode-string/)                                                                                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC394-decodeString.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC394-decodeString.py)                                                                                                         | Decode String                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use a stack to build a string of nested substrings with frequencies associated with each.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Expression Evaluation                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Problems that involve evaluating mathematical or logical expressions. The stack can help manage operators and operands, ensuring the correct order of operations.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Stack                                                                             | M | [](https://leetcode.com/problems/evaluate-reverse-polish-notation/)[150](https://leetcode.com/problems/evaluate-reverse-polish-notation/)                                                                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC150-evaluateReversePolishNotation.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC150-evaluateReversePolishNotation.py)                                                                       | Evaluate Reverse Polish Notation                                            | The order of the elements being popped is important. The first element popped will be the right value in the expression, while the second element popped will be the first. Think about how the elements are appended to a stack and how they are popped to clear up any confusion you may have about this ordering.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Concept: 1) Evaluating arithmetic expressions. 2) Reverse polish notation.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Stack                                                                             | M | [](https://leetcode.com/problems/basic-calculator-ii/)[227](https://leetcode.com/problems/basic-calculator-ii/)                                                                                                                                          |                                                                                                                                                                                                                                                                                      | Basic Calculator II                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use a stack to evaluate an expression without the help of encoded depth of order of operations (parentheses).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Stack                                                                             | H | [](https://leetcode.com/problems/basic-calculator/)[224](https://leetcode.com/problems/basic-calculator/)                                                                                                                                                |                                                                                                                                                                                                                                                                                      | Basic Calculator                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Evaluating arithmetic expressions. 2) Use stack to evaluate expression with addition and subtraction and parentheses for order of operations.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Monotonic Stack                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Problems that involve finding the next greater or smaller element for each element. The stack stores elements in increasing order (for next smaller) or decreasing order (for next greater).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Stack / Monotonic Stack                                                           | E | [](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/description/)[1475](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/description/)                                                           |                                                                                                                                                                                                                                                                                      | Final Prices With a Special Discount in a Shop                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Monotonic increasing stack to get next smaller element. 2) Use tuple of (value, originalIndex) so we can assign values to result array index locations during pop operations.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Stack / Monotonic / Greedy                                                        | M | [](https://leetcode.com/problems/remove-k-digits/)[402](https://leetcode.com/problems/remove-k-digits/)                                                                                                                                                  |                                                                                                                                                                                                                                                                                      | Remove K Digits                                                             | Monotonically increasing stack. Prioritize removing higher elements from left to right.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Use monotonically increasing stack to get next lesser element. 2) greedily remove highest digits from left (most significant digits).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Stack / Monotonic                                                                 | M | [](https://leetcode.com/problems/next-greater-element-ii/)[503](https://leetcode.com/problems/next-greater-element-ii/)                                                                                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC503-nextGreaterElementII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC503-nextGreaterElementII.py)                                                                   | Next Greater Element II                                                     | This is a problem that uses a monotonically decreasing stack. Monotonically decreasing stacks are used to find the next greater element of an element in a linear collection of elements in O(1) time. Since the array is circular, we can copy the array and add it to the end, simulating the circular nature of a circular array. Then we can linearly iterate over the new 2 \* nums array, checking for the next greater element as normal. We return res[:n] because the back half of the result array is not a part of our answer.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Monotonically decreasing stack to next greater element. 2) Circular array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Stack / Monotonic                                                                 | M | [](https://leetcode.com/problems/sum-of-subarray-minimums/description/)[907](https://leetcode.com/problems/sum-of-subarray-minimums/description/)                                                                                                        |                                                                                                                                                                                                                                                                                      | Sum of Subarray Minimums                                                    | Same concept as LC 2104. Really good question to test monotonic stack.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Stack                                                                             | H | [](https://leetcode.com/problems/largest-rectangle-in-histogram/)[84](https://leetcode.com/problems/largest-rectangle-in-histogram/)                                                                                                                     |                                                                                                                                                                                                                                                                                      | Largest Rectangle in a Histogram                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Misc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Stack                                                                             | E | [](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description/)[1614](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description/)                                                                       | Code                                                                                                                                                                                                                                                                                 | Maximum Nesting Depth of the Parentheses                                    | Increment depth when an opening parenthesis is seen and decrement depth when a closing parenthesis is seen.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Use an implicit stack to count the maximum depth of nested parentheses.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Stack                                                                             | E | [](https://leetcode.com/problems/implement-queue-using-stacks/)[232](https://leetcode.com/problems/implement-queue-using-stacks/)                                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC232-implementQueueUsingStacks.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Stack/LC232-implementQueueUsingStacks.py)                                                                               | Implement Queue using Stacks                                                | When implementing a queue using stacks, the operation we need to think about is the pop() method. This is because in a stack, we can just pop from the stack (if look at it like an array, on the right side). But in a queue, we have to popleft (if looking at it like an array, on the left side). To do this, we can move all but the leftmost element in the original stack to another temporary storage stack, pop the leftmost element, then move all of the elements from the temporary stack back to the original stack. This maintains the order of the elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) The operatiosn of a stack and a queue and how they relate to each other.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Array                                                                             |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      | 52                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Queue                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Queue                                                                             | E | [](https://leetcode.com/problems/time-needed-to-buy-tickets/description/)[2073](https://leetcode.com/problems/time-needed-to-buy-tickets/description/)                                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Queue/LC2073-timeNeededToBuyTickets.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Queue/LC2073-timeNeededToBuyTickets.py)                                                                                   | Time Needed to Buy Tickets                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use a queue to simulate queue operations until a condition is met.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Queue                                                                             | M | [](https://leetcode.com/problems/find-the-winner-of-an-array-game/description/)[1535](https://leetcode.com/problems/find-the-winner-of-an-array-game/description/)                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Queue/LC1535-findTheWinnerOfAnArrayGame.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Queue/LC1535-findTheWinnerOfAnArrayGame.py)                                                                           | Find the Winner of an Array Game                                            | We a guaranteed to have the winner after N iterations where N is the length of the array of the game because the max value will be seen in N iterations due to the lesser value being appended to the right. So we can return the maximum of the arr values for the case where k >= len(arr). If k is less than len(arr), we just simulate the game until wins == k. If left > right, we INCREMENT wins by 1 because we want to add to the the current win count since left is always the previous winner. Otherwise, we reset wins to 1 because right is taking the place of left and we say it now has 1 win.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use a queue to simulate queue operations until a condition is met. 2) Popleft and append.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Hash Set                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Hash Set                                                                  | E | [](https://leetcode.com/problems/contains-duplicate/)[217](https://leetcode.com/problems/contains-duplicate/)                                                                                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC217-containsDuplicate.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC217-containsDuplicate.py)                                                                                               | Contains Duplicate                                                          | This is different from LC 287 - "Find the Duplicate Number" because the values for the elements in the array are not constrained to the size of the array, so we can't have an O(1) space approach of indexing into the array using the values. The naïve approaches are double for loop O(N^2) by checking every pair, and O(Nlog(N) + N) by sorting the input nums and for looping through the nums, checking if the number at the current index and the number ahead of it are the same. If space complexity is an issue, then these are possible approaches. They should always be discussed, at least briefly, to demonstrate a better understanding of tradeoffs rather than just knowing the optimal approach.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Use a hash map to store visited values during a linear traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Hash Set                                                                          | M | [](https://leetcode.com/problems/longest-square-streak-in-an-array/description/)[2501](https://leetcode.com/problems/longest-square-streak-in-an-array/description/)                                                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2501-longestSquareStreakInAnArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2501-longestSquareStreakInAnArray.py)                                                             | Longest Square Streak in an Array                                           | This is similar to LC 128 and LC 2154. The complexity issue we need to avoid is having to iterate through the entire array nums to find the next number in the sequence (square of current number). To do this, we just cast nums to a set, so we can find, in O(1) time, if the square of the current number exists in the array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Use a hash set to store the elements in an array. 2) Use a hash set of elements to check in constant time if the next element in a sequence is present in the array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Hash Map                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Hash Map                                                                  | E | [](https://leetcode.com/problems/count-common-words-with-one-occurrence/description/)[2085](https://leetcode.com/problems/count-common-words-with-one-occurrence/description/)                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2085-countCommonWordsWithOneOccurrence.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2085-countCommonWordsWithOneOccurrence.py)                                                   | Count Common Words With One Occurrence                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use two hash maps to store the frequency of each word in their respective arrays of strings and to check the frequency of each word.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Array / hash Map                                                                  | E | [](https://leetcode.com/problems/sum-of-unique-elements/)[1748](https://leetcode.com/problems/sum-of-unique-elements/)                                                                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1748-sumOfUniqueElements.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1748-sumOfUniqueElements.py)                                                                               | Sum of Unique Elements                                                      | Count the number of occurrences of each num in nums and add to a result the nums which have a count of 1. This is the approach to improve the time complexity of a simple double for loop checking if every element is unique.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Use a hash map to count the frequency of each element in an array to determine which elements are unique..                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Array / Hash Map                                                                  | E | [](https://leetcode.com/problems/two-sum/)[1](https://leetcode.com/problems/two-sum/)                                                                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1-twoSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1-twoSum.py)                                                                                                               | Two Sum                                                                     | The brute-force solution to this problem is a double for loop to check every pair by seeing if their sum equals the target. The only other improvement can be on the space complexity, but only when the input array is sorted, which it is for LC 167 - "Two Sum II". But for this problem, O(N) time and O(N) space is the best possible time/space complexity.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) Use a hash map to store visited values during a linear traversal. 2) To find if the current number in a linear traversal can be paired with a visited value to sum up to a target, check if target - currentNum is in the visited hash map.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Array / Hash Map                                                                  | E | [](https://leetcode.com/problems/contains-duplicate-ii/description/)[219](https://leetcode.com/problems/contains-duplicate-ii/description/)                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC219-containsDuplicateII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC219-containsDuplicateII.py)                                                                                           | Contains Duplicate II                                                       | The naïve O(N^2) time complexity approach for this problem is doing a double for loop, checking every pair of values. If we can add O(N) space to the solution, using a hash map is the optimal approach. The difference between this problem and LC 219 - "Contains Duplicate II" is the extra constraint on the difference between indices.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Use a hash map to store pairs of {number : index} to check in O(1) time if a number has been seen and what the index of that number is. 2) Absolute value equation to find an absolute difference pair in constant time using a hash map                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Two Pointers                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Two Pointers                                                              | E | [](https://leetcode.com/problems/remove-element/)[27](https://leetcode.com/problems/remove-element/)                                                                                                                                                     | [](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC27-removeElement.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC27-removeElement.py)                                                                                       | Remove Element                                                              | One thing we have to avoid is swapping values when the right value is equal to val. Since we are doing only one operation per iteration, we are guaranteed to have a situation where the left value is val and the right value is not val. As for using l <= r instead of l < r and returning l instead of r, three isn't really any magic pattern for this. Always try examples because problems like this are plagued with off-by-one errors.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use left and right pointers starting from opposite ends of an array to move target elements to the right side of the array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Array                                                                             | E | [](https://leetcode.com/problems/move-zeroes/)[283](https://leetcode.com/problems/move-zeroes/)                                                                                                                                                          |                                                                                                                                                                                                                                                                                      | Move Zeroes                                                                 | Rearrange/fill an array without extra space comlexity in linear time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Shift target value to left side of array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Array                                                                             | M | [](https://leetcode.com/problems/rearrange-array-elements-by-sign/)[2149](https://leetcode.com/problems/rearrange-array-elements-by-sign/)                                                                                                               |                                                                                                                                                                                                                                                                                      | Rearrange Array Elements by Sign                                            | Rearrange/fill an array without extra space comlexity in linear time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Linear scan array. 2) Use two pointers to track insert positions and to preserve original ordering.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Slow & Fast                                                               | M | [](https://leetcode.com/problems/find-the-duplicate-number/)[287](https://leetcode.com/problems/find-the-duplicate-number/)                                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC287-findTheDuplicateNumber.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC287-findTheDuplicateNumber.py)                                                                                     | Find the Duplicate Number                                                   | There are many other ways to solve this problem, such as sorting and checking the next number, or using a hash set and finding a number that has already been visited. For the O(1) space slow & fast pointer solution, there are detailed proofs online that go into the proper depth needed to describe why it works. I suggest looking at those before citing this solution is something like an interview.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Use slow and fast pointers to find the duplicate number in an array. Use the values as indices.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Array / Two Pointers                                                              | E | [](https://leetcode.com/problems/merge-sorted-array/)[88](https://leetcode.com/problems/merge-sorted-array/)                                                                                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC88-mergeSortedArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC88-mergeSortedArray.py)                                                                                                   | Merge Sorted Array                                                          | This is a standard pointer manipulation problem on an array. The motivation for this is to eliminate the need for extra O(N) space. We have a pointer for the elments in the filled portion of nums1, for the elements in nums2, and for the right side of the nums1 array where we will be assigning values to. We insert right to left so we can preserve num1's beginning elements. We iterate while i >= 0 AND j >= 0 so we don't have a case where we're trying to access a -1 index. When the while loop terminates, if i is greater than or equal to 0, these elements are already inserted since they were in the array to begin with. But if j >= 0, this means we have nums2 elements to still insert.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Use two pointers to traverse two collections of elements simultaneously. 2) Use value comparison to determine which pointer should be updated.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Array / Two Pointers                                                              | E | [](https://leetcode.com/problems/minimum-common-value/description/)[2540](https://leetcode.com/problems/minimum-common-value/description/)                                                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC2540-minimumCommonValue.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC2540-minimumCommonValue.py)                                                                         | Minimum Common Value                                                        | Use a pointer for each array. If the values at each pointer are equal, return that value. Otherwise, increment the index of the value that is less than the other. Do this while we are in bounds of both arrays. If one of the pointers goes out of bounds, we can return -1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Use two pointers to traverse two collections of elements simultaneously. 2) Use value comparison to determine which pointer should be updated.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Array / Two Pointers                                                              | M | [](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)[167](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)                                                                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC167-twoSumII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC167-twoSumII.py)                                                                                               | Two Sum II - Sorted Input Array                                             | This is often a follow-up problem to LC 1 - "Two Sum". We use the sorted property to greedily converge to an answer if it exists. We can greedily converge to an answer because of the sorted property. In LC 1, there is no sorted proeprty so we have to have a set of visited numbers since they could all be a part of the answer. With a sorted array, we know that if we increment or decrement a pointer, it will not be a part of our answer.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Two sum with sorted array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Array / Two Pointers                                                              | M | [](https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/)[1498](https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/)                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC1498-numberOfSubsequencesThatSatisfyTheGivenSumCondition.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC1498-numberOfSubsequencesThatSatisfyTheGivenSumCondition.py)       | Number of Subsequences That Satisfy the Given Sum Condition                 | This is similar to the two sum problem in that we need to find the two numbers in a sorted array that meet a constraint. For counting the number of subsequences, we want to count the number of subsequences given right - left elements. We don't use right - left + 1 because we don't want to include the element at the right index in the subsequence count. This is because nums[right] + nums[right] is not guaranteed to be <= target. So we instead wait for left == right to include it.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Number of subsequences formula, 2^n. 2) Subsequences can be rearranged (sorted in this case) when order of the elements does not matter.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Array / Two Pointers                                                              | M | [](https://leetcode.com/problems/3sum/)[15](https://leetcode.com/problems/3sum/)                                                                                                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC15-3Sum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC15-3Sum.py)                                                                                                         | 3Sum                                                                        | This is essentially LC 167 - "Two Sum II" inside of a for loop. The tricky part is making sure we don't have duplicates. To do this, we have to do two things: 1) Skip a left index if it is equal to the previous left value. This is because we will always get a duplicate pair in this case. 2) Skip mid and right indices that have the same values as their previous values. This again is because, without skipping, we will always produce a duplicate 3-pair.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Find all triplets that sum up to a target value by using a two pointer technique inside of a for loop.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Array / Greedy / Two Pointers                                                     | M | [](https://leetcode.com/problems/container-with-most-water/)[11](https://leetcode.com/problems/container-with-most-water/)                                                                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC11-containerWithMostWater.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Two%20Pointers/LC11-containerWithMostWater.py)                                                                     | Container With Most Water                                                   | Finding the area might be tricky for some people when dealing with indexes since something like counting characters in a sliding window is r - l + 1, whereas with area you're just doing r - l. It's a matter of understanding the difference between being inclusive and exclusive with subtraction of indices.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) Greedily start at opposite ends of array and greedily increment the shorter height side.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Pivot Partition                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | A subset of prefix/postfix sum problems where you partition the string by a pivot and update the prefix/postfix information at each pivot index.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Array                                                                             | E | [](https://leetcode.com/problems/find-the-middle-index-in-array/description/)[1991](https://leetcode.com/problems/find-the-middle-index-in-array/description/)                                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC1991-findTheMiddleIndexInArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC1991-findTheMiddleIndexInArray.py)                                                                             | Find the Middle Index in Array                                              | Same question as LC 724 - Find Pivot Index                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Partition array with left and right side, starting right side with sum of all elements and remove from right/add to left at each iteration.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Prefix / Postfix                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Prefix Sum                                                                | M | [](https://leetcode.com/problems/count-vowel-strings-in-ranges/description/)[2559](https://leetcode.com/problems/count-vowel-strings-in-ranges/description/)                                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC2559-countVowelStringsInRanges.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC2559-countVowelStringsInRanges.py)                                                                             | Count Vowel Strings in Ranges                                               | Given the upper bound constraints, we are looking for a solution in the range of linear time complexity. So the main complexity issue is having 10^5 queries and 10^5 words. We need a way to access the number of words that have the property specified in the query range in CONSTANT time. So we are trying to find a way to make this an O(1) lookup. This logic becomes more easy to identify when you know about prefix sums. And that is what we do for this problem. Lienarly iterate through the words, counting the number of words up until this word that match the trait and adding it to an array that we can index into later. For the range, using prefix sums and doing r - l means subtract prefixes to left of r by the prefixes to the left of l, which produces the count between l and r.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Use prefix sum array and the idea of subtracting the start prefix sum from the end prefix sum to get the sum in a range.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Array                                                                             | M | [](https://leetcode.com/problems/product-of-array-except-self/)[238](https://leetcode.com/problems/product-of-array-except-self/)                                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC238-productOfArrayExceptItself.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC238-productOfArrayExceptItself.py)                                                                             | Product of Array Except Self                                                | The brute-force solution to this problem is to store the prefix and postfix products in left and right arrays respectively to calculate the value at each index. The improvement on this brute-force solution is with not having to use extra space. A common optimization theme with array problems is finding a way to solve the problem without extra space.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Prefix and postfix products.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Array                                                                             | M | [](https://leetcode.com/problems/subarray-sum-equals-k/)[560](https://leetcode.com/problems/subarray-sum-equals-k/)                                                                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC560-subarraySumEqualsK.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC560-subarraySumEqualsK.py)                                                                                             | Subarray Sum Equals K                                                       | This problem at first glance might look like a dynamic size sliding window could be an optimal approach. The factor in this problem that makes this not possible is the fact that negative numbers can be in the array. We cannot guarantee that increasing the window size will increase the sum or decreasing the array decreases the sum. We also put 0 in the hash map because we want to count all of the subarrays equal to K that start at index 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Prefix sums to get all subarray sums equal to K.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Array / Postfix                                                                   | M | [](https://leetcode.com/problems/partition-array-into-disjoint-intervals/description/)[915](https://leetcode.com/problems/partition-array-into-disjoint-intervals/description/)                                                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC915-partitionArrayIntoDisjointIntervals.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC915-partitionArrayIntoDisjointIntervals.py)                                                           | Partition Array into Disjoint Intervals                                     | The naïve approach of iterating through the array and checking if the maximum of the left subarray is >= the minimum of the right subarray is fairly trivial. We can have a running minimum on the left side, but how do we get the maximum on the right in constant time? We can't because the maximum could change, and in the worst case it could change at every iteration, so we would be calling an O(N) max operation at each iteration, which isn't feasible with the input array size having an upper bound of 10^5. So we instead need to realize we can use the idea of a postfix array. Iterating from the right, we can create a postfix array (exclusive) where every array entry is the min value of the subarray to the RIGHT of it (again, exclusive). We specify it is exclusive so when we are iterating through the array to find the answer, we INCLUDE the maximum at this index, and look at the minimum of the right subarray.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Postfix minimum array in conjunction with a running maximum value to see when every element in the left side is less than or equal to every element on the right side.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Breadth-First Search                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / BFS                                                                       | M | [](https://leetcode.com/problems/jump-game-iii/description/)[1306](https://leetcode.com/problems/jump-game-iii/description/)                                                                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC1306-jumpGameIII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC1306-jumpGameIII.py)                                                                                                         | Jump Game III                                                               | The first step in being able to come up with a solution for this problem is understanding we need to brute-force the search of the value 0. The reason this is the case is because there is no way to intelligently converge to an index whose value is 0. The second step is understanding what brute-force techniques we have at our disposal that might make sense for the problem. Here you might say backtracking, DFS, BFS. Backtracking is DFS with pruning and we are technically pruning the choice space beyond the starting and ending indices of the array, so it can be considered to be the same. But it is sufficient to just say you're doing DFS or BFS if you're using that.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Breadth-First Search on an array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Array / BFS                                                                       | M | [](https://leetcode.com/problems/keys-and-rooms/)[841](https://leetcode.com/problems/keys-and-rooms/)                                                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC841-keyAndRooms.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC841-keyAndRooms.py)                                                                                                             | Keys and Rooms                                                              | It might not be immediately obvious that this is a BFS problem if you've never solved a problem like this. BFS can be used to solved problems on arrays just like trees and graphs. The rooms are the entries in the rooms array and the keys are the edges to the next room.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Breadth-First Search on an array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Misc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Hash Map                                                                          | E | [](https://leetcode.com/problems/rank-transform-of-an-array/description/)[1331](https://leetcode.com/problems/rank-transform-of-an-array/description/)                                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1331-rankTransformOfAnArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1331-rankTransformOfAnArray.py)                                                                         | Rank Transform of an Array                                                  | You can't avoid the sorting. We need a prev variable because if two elements are the same, we don't want to increase the rank. We start rank at 0 because that's just how the flow of the algorithm handles duplicate elements. Rank can start at 1 but the logicical flow of updating rank will have to be changed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Concept: 1) If an original index is needed of an element after some rearrangement of the elements, create a new array with tuples of (original element, original index).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Array / String                                                                    | E | [](https://leetcode.com/problems/sort-the-people/)[2418](https://leetcode.com/problems/sort-the-people/)                                                                                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC2418-sortThePeople.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC2418-sortThePeople.py)                                                                                                     | Sort the People                                                             | This problem is a perfect example of why list comprehension is a huge benefit that Python provides. However, it is important to not get too comfortable with it as an interviewer might ask you to write it in a more manual way so less of the algorithm is abstracted away.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Sorting is based on first element in tuple and next elements break ties.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Array                                                                             | E | [](https://leetcode.com/problems/majority-element/)[169](https://leetcode.com/problems/majority-element/)                                                                                                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC169-majorityElement.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC169-majorityElement.py)                                                                                                   | Majority Element                                                            | The O(N) space approach is to just use a hash map and get the counts of each element and return the element that has the highest count. The optimal O(1) space approach is called the Boyer-Moore Voting Algorithm. It works by incrementing the count if we see the same number and decrement if we see a different number. Since the majority element appears more than n / 2 times, we can't discard the majority element more than the minority elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) To get majority element in O(1) space, keep running count of current element and when the count becomes 0, update the max element to this newly seen element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Circular Array                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array                                                                             | E | [](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/description/)[2515](https://leetcode.com/problems/shortest-distance-to-target-string-in-a-circular-array/description/)                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC2525-shortestDistanceToTargetStringInACircularArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC2525-shortestDistanceToTargetStringInACircularArray.py)                                   | Shortest Distance to Target String in a Circular Array                      | The formulas for wrapping around an array: if going forward: (startIndex + i) % n. If going backward: (startIndex - i + n) % n.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Circular array. 2) Minimum distance from source index to target index in a circular array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Array / Circular Array                                                            | E | [](https://leetcode.com/problems/defuse-the-bomb/description/)[1652](https://leetcode.com/problems/defuse-the-bomb/description/)                                                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC1652-defuseTheBomb.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC1652-defuseTheBomb.py)                                                                                                     | Defuse the Bomb                                                             | Use the trick to wrap around an array using (index + change) % len(arr) and (index - change + len(arr)) % len(arr). This can be done in more efficient time by precomputing prefix/suffix sum arrays.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Ciruclar array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Pairs                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | For loops to get all pairs.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Array                                                                             | E | [](https://leetcode.com/problems/count-equal-and-divisible-pairs-in-an-array/description/)[2176](https://leetcode.com/problems/count-equal-and-divisible-pairs-in-an-array/description/)                                                                 |                                                                                                                                                                                                                                                                                      | Count Equal and Divisible Pairs in an Array                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Double for loop to get all pairs.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Array / Hash Set                                                                  | E | [](https://leetcode.com/problems/count-square-sum-triples/description/)[1925](https://leetcode.com/problems/count-square-sum-triples/description/)                                                                                                       |                                                                                                                                                                                                                                                                                      | Count Square Sum Triples                                                    | Requires an improvement on O(N^3) to O(N^2). We can do this by creating a hash set of all c^2 values so we can do O(1) lookups. The c for loop is able to be removed because we only need to worry about the PERMUTATIONS of a and b. c will always be the same value depending on what is chosen for a and b.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Get permutations of pairs of values in an array. 2) Use a hash set to efficiently check if a value has been seen in the array during a linear traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Greedy                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Problems where you're generally asked to minimize or maximize something. If has the greedy choice property (locally optimal choice at each step produces the optimal solution), then the greedy solution can be applied.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Array / Greedy                                                                    | E | [](https://leetcode.com/problems/lemonade-change/)[860](https://leetcode.com/problems/lemonade-change/)                                                                                                                                                  |                                                                                                                                                                                                                                                                                      | Lemonade Change                                                             | Really good greedy problem. To determine if we can provide every customer with the correct change, we must try to find an optimal ordering of giving change. The leap to understanding that this simply just requires a greedy strategy of picking the largest bill first, we have to understand that we can always make change with 5's for a 20, but only have one option to make change for 5 (use a 5).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Greedily pick the most restricted choice first when possible to minimize the possibility of being stuck with a restricted choice later.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Array / Hash Map / Greedy                                                         | M | [](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/description/)[2244](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/description/)                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2244-minimumRoundsToCompleteAllTasks.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2244-minimumRoundsToCompleteAllTasks.py)                                                       | Minimum Rounds to Complete All Tasks                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Greedily choose to take away the maximum from a source at each step if trying to minimize the steps to deplete the source.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Greedy / Array                                                                    | M | [](https://leetcode.com/problems/gas-station/)[134](https://leetcode.com/problems/gas-station/)                                                                                                                                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC134-gasStation.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC134-gasStation.py)                                                                                                             | Gas Station                                                                 | Since we need a starting index that has a net positive gas accumulation along the route, we can greedily check this by keeping a running sum of the amount of gas we have at a given index. If it drops below 0, then no indices before and including this index can be the starting point. So we then try index + 1 as the starting point.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Concept: 1) Greedily update start when gas count becomes less than 0. Similar to LC 169: Majority Element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Array / Greedy / Postfix Sum                                                      | H | [](https://leetcode.com/problems/reducing-dishes/description/)[1402](https://leetcode.com/problems/reducing-dishes/description/)                                                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Greedy/LC1402-reducingDishes.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Greedy/LC1402-reducingDishes.py)                                                                                                 | Reducing Dishes                                                             | If we have an array of [1, 2, 3], starting from the right, at 2 our prefix sum will 5 and our total sum will be 3. If we add the prefix sum to the total sum, we get 8. Which is the same as doing 2 \* 1 + 3 \* 2. This is the idea of this problem. We can, in O(N) time, get the optimal starting index and thus the best multipliers for each value by greedily starting from the highest value, adding the prefix sum to a running total sum, and getting the max total sum.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) Using postfix sum with a running total sum to dynamically increase the multiplier for each value by 1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Array / Greedy                                                                    | E | [](https://leetcode.com/problems/minimum-absolute-difference/description/)[1200](https://leetcode.com/problems/minimum-absolute-difference/description/)                                                                                                 |                                                                                                                                                                                                                                                                                      | Minimum Absolute Difference                                                 | Similar to LC 2294                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Greedily sort. 2) To get all unique pairs with the minimum absolute difference, greedily pair up adjacent elements in a sorted array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Array / Greedy                                                                    | E | [](https://leetcode.com/problems/maximum-units-on-a-truck/description/)[1710](https://leetcode.com/problems/maximum-units-on-a-truck/description/)                                                                                                       |                                                                                                                                                                                                                                                                                      | Maximum Units on a Truck                                                    | Good greedy problem.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Concept: 1) Greedily pick the element that contributes the most to the result at each step.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Array                                                                             | M | [](https://leetcode.com/problems/largest-number/)[179](https://leetcode.com/problems/largest-number/)                                                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC179-largestNumber.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Array/LC179-largestNumber.py)                                                                                                       | Largest Number                                                              | We want to greedily pick the largest digit starting from the most significant digit. If we have a choice between 9 and 79, we pick 9 because 9 > 7. If we have a choice between 3 and 39, we choose 39 because 393 > 339. So we compare the concatenation of every pair of values, sorting them based on what their concatenation would produce.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Sort via custom comparator. 2) Get largest number by greedily choosing highest number at most significant digit.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Array / Greedy                                                                    | M | [](https://leetcode.com/problems/minimum-increment-to-make-array-unique/description/)[945](https://leetcode.com/problems/minimum-increment-to-make-array-unique/description/)                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Greedy/LC945-minimumIncrementToMakeArrayUnique.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Greedy/LC945-minimumIncrementToMakeArrayUnique.py)                                                             | Minimum Increment to Make Array Unique                                      | The upper bound of the length of nums is 10^5, so we want something better than O(N^2) time complexity. So we want to avoid a double for loop. When seeing "minimum number of moves to make every value unique", sorting immediately jumped out at me because intuitively it makes sense that you want to raise each value only just enough such that it is 1 higher than the previous. This is a pretty common line of thinking with greedy problems like this.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) To minimize the number of increments to various values to make an array of strictly unique numbers, we must sort the array and increment (starting from the minimum value) every value 1 + previous value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Intervals                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Array / Greedy                                                                    | E | [](https://leetcode.com/problems/maximum-population-year/description/)[1854](https://leetcode.com/problems/maximum-population-year/description/)                                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Intervals/LC1854-maximumPopulationYear.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Intervals/LC1854-maximumPopulationYear.py)                                                                             | Maximum Population Year                                                     | This problem can be solved using the same logic as in LC 253 - Meeting Rooms II. We are trying to count the number of number of people alive at any given time. To do so, we want to simultaneously count the number of deaths in the current year and then the number of births in the current year (this order is important because the problem specifies people aren't counted in the year that they die). We can split the birth years and death years into two arrays, sort them, use two pointers to mark or current position in each array, and pick the lower year between the two to increment/decrement the cur_count of people. If the years are equal, we use the deaths year first and continue to the next iteration.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Put intervals into start and end arrays and sort them to traverse them with two pointers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Array / Greedy                                                                    | M | [](https://leetcode.com/problems/merge-intervals/)[56](https://leetcode.com/problems/merge-intervals/)                                                                                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Intervals/LC56-mergeIntervals.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Intervals/LC56-mergeIntervals.py)                                                                                               | Merge Intervals                                                             | Sorting the intervals allows us to guarantee that overlapping intervals will be next to each other in the list of intervals and we can also know that the start of the left interval in a list will always be less than or equal to the right interval. We only need prev_e instead of prev_s for this reason. Also, without sorting you would have to check each interval against every other interval to get the new intervals.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) Presort intervals. 2) Merge intervals by check previous end with current start to either update previous interval end or add new interval.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Array / Greedy                                                                    | M | [](https://leetcode.com/problems/insert-interval/)[57](https://leetcode.com/problems/insert-interval/)                                                                                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Intervals/LC57-insertInterval.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Intervals/LC57-insertInterval.py)                                                                                               | Insert Interval                                                             | All interval problems require the tracking of start/end times for the intervals and using that information to solve the problem. With inserting an interval, we have to merge intervals. This is why we need a new result array that needs to be built up. There are three cases: the new interval's end is before the current interval's start, the new interval's start is after the current interval's end, and the intervals overlap.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) To insert an interval, we need traverse every interval so we can merge the intervals that overlap with the new interval.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Array                                                                             | E | [](https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/)[1450](https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/)                                                                             | [](https://github.com/BrandonKenter/Solutions/blob/main/Intervals/LC1450-numberOfStudentsDoingHomeworkAtAGivenTime.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Intervals/LC1450-numberOfStudentsDoingHomeworkAtAGivenTime.py)                                     | Number of Students Doing Homework at a Given Time                           | Iterate over start and end times and add to count when interval includes queryTime.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Check how many intervals intersect a single point.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Array / Heap                                                                      | H | [](https://leetcode.com/problems/minimum-interval-to-include-each-query/)[1851](https://leetcode.com/problems/minimum-interval-to-include-each-query/)                                                                                                   |                                                                                                                                                                                                                                                                                      | Minimum Interval to Include Each Query                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Check the minimum interval width that intersects with a single point.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Array / Greedy                                                                    | M | [](https://leetcode.com/problems/remove-covered-intervals/description/)[1288](https://leetcode.com/problems/remove-covered-intervals/description/)                                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Intervals/LC1288-removeCoveredIntervals.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Intervals/LC1288-removeCoveredIntervals.py)                                                                           | Remove Covered Intervals                                                    | Sort the intervals so we can check adjacent intervals (otherwise we would have to do an O(N^2) loop to check every interval against every other one). But a simple sort will sort by the start and then the end. So [1, 2] will come before [1, 3]. This is not what we want because we will be keeping a prev_e variable (to avoid needing O(N) space) and checking the next interval's end time to see if it is less than prev_e. To do this, we must also make sure the end interval is sorted in reverse order (higher end interval comes before lower). To do this, we use a lambda function as our key in the sort method and use the interval pair as x[0], -x[1].                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Presort intervals. 2) Pop previous interval if current interval covers previous or skip if previous interval covers current interval.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Graph                                                                             |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Trivial Search                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Trivial DFS / BFS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Graph / DFS / BFS / Union-Find                                                    | E | [](https://leetcode.com/problems/find-if-path-exists-in-graph/)[1971](https://leetcode.com/problems/find-if-path-exists-in-graph/)                                                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC1971-findIfPathExistsInGraph.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC1971-findIfPathExistsInGraph.py)                                                                                 | Find if Path Exists in Graph                                                | Two other appropriate approaches are BFS and Union-Find. For BFS, create the same adjacency list and run a standard BFS on the source, popping from the queue until destination is found or until the queue is empty. For Union-Find, union every edge. Then check if the ultimate parent of the source is equal to the ultimate parent of the desetination. If they are equal, it means there is a path between the two. If not, there is no path since they are in different connected components.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Graph                                                                             | E | [](https://leetcode.com/problems/destination-city/description/)[1436](https://leetcode.com/problems/destination-city/description/)                                                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC1436-destinationCity.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC1436-destinationCity.py)                                                                                                 | Destination City                                                            | We need to create a hash map of a -> b mappings, otherwise we would have to do a linear scan through the paths to find the adjacent city every time we move cities. We also use a standard dictionary, not a defaultdict of lists because we are guaranteed to have a simple line of cities with no loops, so every node has 1 edge. This also means we don't need a visited set and can call the dfs once on any node and are guaranteed to find the destination node. Lastly, we have the choice of using a variable outside of the dfs as a placeholder for the destination city and when we find it we can assign that variable to the current node and return that. But generally we want to avoid this if we can do it in a clean way, so we instead return the destination node at the base case and also add a return statement to the recursive dfs call.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Graph / DFS                                                                       | M | [](https://leetcode.com/problems/all-paths-from-source-to-target/)[797](https://leetcode.com/problems/all-paths-from-source-to-target/)                                                                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC797-allPathsFromSourceToTarget.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC797-allPathsFromSourceToTarget.py)                                                                             | All Paths From Source to Target                                             | I have had a lot of small confusion with paths because I didn't think about this: If it is a path of characters in a string and you concatenate a char to the current string path, this creates a copy and a new reference. So when the DFS backtracks, it is using the previous path reference. This is why you don't need to pop() from the path with string paths. But also string concatenation is O(N) time, so you would want to store the chars in an array anyway and use "".join(), which would mean you would still have to pop().                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Concept: 1) Getting all paths from a source to a target of a DAG using a nonlocal path list to append/pop to and from.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Unweighted Shortest Path                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | BFS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Graph / Hash Map / BFS                                                            | H | [](https://leetcode.com/problems/bus-routes/)[815](https://leetcode.com/problems/bus-routes/)                                                                                                                                                            |                                                                                                                                                                                                                                                                                      | Bus Routes                                                                  | We use a stop : bus map instead of a bus : stop map because we are trying to find the shortest distance of busses. We want to add the stops adjacent to the current level of busses to the queue. To do that, we must find all stops adjacent to a bus. You can't do this with a bus : stop map.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: BFS.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Weighted Shortest Path                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Dijkstra's                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Graph / Dijkstra's / Weighted / Directed                                          | M | [](https://leetcode.com/problems/network-delay-time/)[743](https://leetcode.com/problems/network-delay-time/)                                                                                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph%20Traversal/Shortest%20Path/Dijkstra's/LC743-networkDelayTime.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph%20Traversal/Shortest%20Path/Dijkstra's/LC743-networkDelayTime.py)                   | Network Delay Time                                                          | \*\*\*Directed edges means the path from a to b isn't guaranteed since the component can be weakly connected. This isn't a problem with undirected edges.\*\*\* The goal of this problem is to visit every node and return the weight of the heaviest path (the highest time) of all of the shortest paths to each node. We don't need a visited array/set because 'times' acts as our visited check with the line 'if new_time < times[nei_node]'. Visited nodes will never pass this line. We do the 'if times[cur_node] < cur_time' check to discard stale nodes. This is a general Dijkstra's improvement and is not unique to this problem. We could use a visited set and then return the time it took to get to the last visited node, but that requires unnecessary extra space. We can just iterate over the times array, get the max time and return that. And if there is a float('inf') time, this means this node was not reachable from the source node, so we return -1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Dijkstra's algorithm. 2) Shortest path in a weighted directed graph with positive edge weights.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Graph / Weighted / Undirected / Shortest Path / Dijkstra's                        | M | [](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/)[1976](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/)                                                                                                 |                                                                                                                                                                                                                                                                                      | Number of Ways to Arrive at Destination                                     | This is different than other shortest path problems because we are asked to find the total number of shortest paths to a node. It is not sufficient to just count the number of times we reach the destination node with the shortest distance because each path to get to the destination could actually have many different paths that lead to the same destination. So if the new distance to a neighbor node is less than the distance that is currently in the distance array for this neighbor node, update the ways entry for this neighbor node to the number of ways for the current node. Otherwise, if the new distance to a neighbor node is equal to the distance that is currently in the distance array for this neighbor node, increment the ways entry for this neighbor node by the number of ways for the current node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Dijkstra's algorithm. 2) Shortest path in a weighted undirected graph with positive edge weights. 2) Number of ways to arrive at a destination in the shortest distance.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Floyd Warshall                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Graph / Floyd Warshall / Undirected / Directed / Weighted / Multi-Source          | M | [](https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/)[1334](https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/) |                                                                                                                                                                                                                                                                                      | Find the City With the Smallest Number of Neighbors at a Threshold Distance | A graph may be given as an undirected graph. In this case, make sure to populate the adjacency matrix with edges going both directions. IMPORTANT NOTE: This problem can also be solved using Dijkstra's by running it on every node and it will be a time complexity of O(V\*Elog(V)).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Floyd Warshall                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Prim's Algorithm                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   | [](https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/description/)[1489](https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/description/)                       |                                                                                                                                                                                                                                                                                      | Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Graph Coloring                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Graph / BFS / DFS                                                                 | M | [](https://leetcode.com/problems/possible-bipartition/description/)[886](https://leetcode.com/problems/possible-bipartition/description/)                                                                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC886-possibleBipartitionDFSandBFS.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC886-possibleBipartitionDFSandBFS.py)                                                                         | Possible Bipartition                                                        | \*Brief implementation thought process: set start to 0, if nei is colored and == cur, return False. Otherwise, color it.\* Acyclic graphs are always bipartite. Cyclic graphs with even length cycles are bipartite. Cyclic graphs with one or more odd length cycles cannot be bipartite. For these problems that connected components are not guaranteed, we run a for loop to execute the search (DFS or BFS) on every node if they haven't already been visited (colored in this case). The "if it is False for one call, return False as the answer. It has to be True for all to return True" pattern is common with graph search problems. Being able to identify these types of problems helps with constructing the functions, especially DFS where we have to "bubble up" return values from deeper calls to the top call. We also don't need a visited set because the colors array acts as a visited set, if the color is -1, then it is unvisited and visited otherwise.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Graph 2-coloring.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Topological Sort                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Used for cycle detection/finding a topological ordering. Kahn's algorithm can't be used for directed graphs, but can be used for undirected graphs.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Graph / DFS / BFS (Kahn's) / Topological Sort / DAG                               | M | [](https://leetcode.com/problems/course-schedule/)[207](https://leetcode.com/problems/course-schedule/)                                                                                                                                                  | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC207-courseSchedule.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC207-courseSchedule.py)                                                                                                     | Course Schedule                                                             | Why use topological sort for this problem? Because we are essentially being asked if a topological ordering exists. Topological orderings can be made only on DAGs. So our goal is to find if a topological ordering can exist for the given courses. A course schedule is 1) directed because for a course you have an edge directed to a prerequisite, 2) there can be no cycle or cyclic dependency between courses and 3) the problem can be expressed as a graph because every course -> prerequisite can be thought of as an edge. For this problem, we are asked \*IF\* a course schedule is possible. So we need to keep track of our current path in the case of DFS to detect a cycle. In the case of BFS (Kahn's), it is sufficient to check if the number of nodes we have identified as feasible in a topological ordering equals the number of courses.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Concept: 1) Chcek if a topological ordering is possible (detect if there is a cyclic dependency or not). Can do with DFS or Kahn's.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Graph / DFS / BFS (Kahn's) / Topological Sort / DAG                               | M | [](https://leetcode.com/problems/course-schedule-ii/)[210](https://leetcode.com/problems/course-schedule-ii/)                                                                                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC210-courseScheduleII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC210-courseScheduleII.py)                                                                                                 | Course Schedule II                                                          | The only difference between Course Schedule and Course Schedule II is we want to return the ordering in Course Schedule II. So for DFS, we build up the topological ordering in an array and if we detect a cycle, we immediately return an empty array. As for BFS (Kahn's), we do the same algorithm as other implementations of Kahn's and return the ordering (reversed) if the size of the ordering is the number of courses, or an empty array otherwise. Why do we reverse for the DFS in topological sort question and not reverse for the DFS in course schedule and the opposite for BFS (both are topological sort, I'm just talking about the GFG question vs this leetcode quesetion)? The topological sort question asks for the ordering of "Do this, then this, then this…" while this question asks for the order of "Do this before this, before this, before this…"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Use topological sort to order courses. The direction of the ordering between DFS and Kahn's is important to understand.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Graph / DFS / BFS (Kahn's) / Topological Sort / DAG                               | M | [](https://leetcode.com/problems/find-eventual-safe-states/)[802](https://leetcode.com/problems/find-eventual-safe-states/)                                                                                                                              | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC802-findEventualSafeState.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC802-findEventualSafeState.py)                                                                                       | Find Eventual Safe States                                                   | Terminal nodes have an outdegree of 0. Safe nodes have all paths leading to a terminal node. If a node has a path to a cycle or is a part of a cyle, it cannot be a safe node. All other nodes are considered safe nodes. We don't need to sort the ans array for DFS because we are calling and adding safe nodes in ascending order. Adding inside the DFS function WOULD create a topological ordering, but we don't want a topological ordering. We want a sorted ordering. So calling dfs from 0 to n and adding each node that is safe to res makes sure it is in sorted order. For BFS, ascending ordering is not guaranteed because we are adding when the indegree for a node reaches 0 which can be in any order, so the res array must be sorted. The reason we reverse the graph for BFS: The initial starting safe nodes are the terminal nodes. For this problem, those are nodes with an outdegree of 0. For Kahn's, we care about indegree of 0. So we reverse the edges to get indegrees of each node. NOTE: We don't need a visited set for Kahn's because we only add nodes to the queue when the indegree becomes 0. Nodes in a cycle cannot reach an indegree of 0. We need an adjacency list for Kahn's algorithm and not for DFS because we are reversing the edges for Kahn's, so we need an adjacency list to find all of the nodes on the reverse end in constant time.                                                                                                                                                                                                                                                               | Concept: 1) The relationship between topological sort and safe nodes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Misc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Graph / DFS / BFS                                                                 | M | [](https://leetcode.com/problems/clone-graph/)[133](https://leetcode.com/problems/clone-graph/)                                                                                                                                                          |                                                                                                                                                                                                                                                                                      | Clone Graph                                                                 | For DFS/BFS on undirected graphs or graphs that can contain cycles, it is important to have some sort of cycle detection. In this case, we are creating a hash map from old to new nodes, so if we see an old node we have already visited, we can just return that new node in the case of DFS, or just append to that new node's neighbors list in the case of BFS. The nuances between DFS and BFS implementations need to be understood because reading a solution is a much worse level of understanding compared to actually knowing the little details like why you seed the hash map before running BFS.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Clone a graph.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Disjoint Set                                                                      |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Count Connected Components                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Graph / Disjoint Set / Union Find                                                 | M | [](https://leetcode.com/problems/number-of-provinces/)[547](https://leetcode.com/problems/number-of-provinces/)                                                                                                                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC547-numberOfProvinces.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC547-numberOfProvinces.py)                                                                                               | Number of Provinces                                                         | This problem can also be done using DFS, BFS or Union-Find all efficiently. If solving with union find, the goal is to start at a number of provinces = N where N is the number of nodes. For every cell (I, j) in isConnected, if i and j are connected, continue. Otherwise, union them and decrement the number of provinces by 1. For DFS/BFS, we can use the adjacency matrix to traverse the nodes to avoid using extra space for an adjacency list. Additionally, we need to count up to the number of provinces from 0 after each DFS call. We can't count down because there is no trait of connected components that we can leverage in constant time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) Use union-find to get number of connected components.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Graph / Disjoint Set / Union Find                                                 | M | [](https://leetcode.com/problems/number-of-operations-to-make-network-connected/)[1319](https://leetcode.com/problems/number-of-operations-to-make-network-connected/)                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Union%20Find/LC1319-numberOfOperationsToMakeNetworkConnected.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Union%20Find/LC1319-numberOfOperationsToMakeNetworkConnected.py)                                 | Number of Operations to Make Network Connected                              | NC connected components require NC - 1 edges to make them all connected. So just union every pair if they have different parents, and if they have same parent count this as an extra edge that can be use to connect the final components. We just return NC - 1 if the extra edges is >= NC - 1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: Count number of edges that can be removed while still maintaining the connected trait of a connected component.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Detect Cycle                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Graph / Disjoint Set / Union Find                                                 | M | [](https://leetcode.com/problems/redundant-connection/)[684](https://leetcode.com/problems/redundant-connection/)                                                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Union%20Find/LC684-redundantConnection.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Union%20Find/LC684-redundantConnection.py)                                                                             | Redundant Connection                                                        | Make sure to pay attention to 0-based indexing and 1-based indexing for nodes. When the problem provides a graph that is 1-based, we allocate space for n + 1. The first entry in the parents and sizes arrays won't be used, it's just way more clean to do it this way.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: Find first redundant connection.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Kruskal's Algorithm                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Graph / Prim's / MST / Undirected / Weighted                                      | M | [](https://leetcode.com/problems/min-cost-to-connect-all-points/)[1584](https://leetcode.com/problems/min-cost-to-connect-all-points/)                                                                                                                   |                                                                                                                                                                                                                                                                                      | Min Cost to Connect All Points                                              | There are two main ways to solve this problem: Prim's and Kruskals. This entry describes how to solve this problem using Prim's algorithm. If you want to see the implementation notes on Kruskal's, see the other entry for this problem. The main idea of this Prim's approach is the add every possibility from the starting node and greedily pick the lowest weighted edge. Then we add another set of edges from this new vertex to the min heap and pick the lowest edge again from all edges includin these new set of edges. It is important to understand that we don't necessarily pick from the newly added edges from the previous vertex we picked. If the first vertex added weights (1, 2, 3), we pick the vertex that has weight 1 and that vertex contributes new edges that are (100, 101, 102), those new weights are added to the min_heap and get pushed down. So on the next iteration, 2 will be picked, not any of the (100, 101, 102). KRUSKAL'S: The main idea of this Kruskal's approach is to get all the possible edges between all nodes, sort them, and then greedily join the edges together making sure we are picking the lowest weighted edge each time that will not create a cycle.                                                                                                                                                                                                                                                                                                                                                                                                                                       | Concept: 1)Kruskal's algorithm.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Graph / Disjoint Set / Union Find                                                 | H | [](https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/description/)[2127](https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/description/)                                                               |                                                                                                                                                                                                                                                                                      | Maximum Employees to Be Invited to a Meeting                                | Remove. Use in the hard concepts list later.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Dynamic Programming                                                               |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Fibonacci                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Express state as (i) where i is the index of the linear collection of elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| DP / Fibonacci                                                                    | E | [](https://leetcode.com/problems/climbing-stairs/)[70](https://leetcode.com/problems/climbing-stairs/)                                                                                                                                                   | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Fibonacci/LC70-climbingStairs.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Fibonacci/LC70-climbingStairs.py)                                                   | Climbing Stairs (Memoization)                                               | A big part of this problem that stumps people is why some people write the base case for i == 0 as returning 1. Intuitively the subproblem of 0 steps should be 0 ways, right? This is true. It boils down to 0-based and 1-based indexing and its relation to this problem. If we start at no steps being case i == 0, we must shift our goal state to be in the cell n + 1. Then the top (nth) step is n+1. For the context of the problem, it really is just a matter of understanding this difference, explaining why you use one base case over another, and understanding what cell in the dp table your answer sits in. Same problem as LC 509.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Concept: 1) Count number of subsequence ways. 2) Fibonacci sequence.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| DP / Fibonacci                                                                    | E | [](https://leetcode.com/problems/min-cost-climbing-stairs/)[746](https://leetcode.com/problems/min-cost-climbing-stairs/)                                                                                                                                | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Fibonacci/LC746-minCostClimbingStairs.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Fibonacci/LC746-minCostClimbingStairs.py)                                   | Min Cost Climbing Stairs (Memoization)                                      | For this problem, we can identify that we are being asked to find the all possible ways and take the best way. Why would a greedy solution not work? Because greedy isn't guaranteed to result in finding the min path. We could miss out on a choice that would decrease the min cost, so we need to try ALL possible ways. Since memoization solves the problem in a top-down manner, think of what our last choice will be. We could jump to the last step from the n - 1 step or from the n - 2 step. Of these two choices, we want to take the minimum. And for the recursive case, we want to take the cost at our current step + the minimum of i - 1 and i - 2 steps. We need base cases for the 0th and 1st steps, both of which will be their respective step costs.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Concept: 1) Get the minimum subsequence sum. 2) Fibonacci sequence.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Subsequence                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Description: Given N items, pick a subsequence to maximize, minimize or count some goal state.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| DP / Subsequence                                                                  | M | [](https://leetcode.com/problems/house-robber/)[198](https://leetcode.com/problems/house-robber/)                                                                                                                                                        | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Subsequences/LC198-houseRobber.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Subsequences/LC198-houseRobber.py)                                                 | House Robber (Memoization)                                                  | This is a subsequence problem where you have choices to pick/not pick elements. We can pick the current and then add the index - 2 position, or not pick the current and add the index - 1 position. This is the "do stuffs on index" step. Since we are interested in the maximum, we get the max of pick and not pick at each index. f(index) describes the maximum sum of 0 to that index.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Concept: 1) Get the maximum subsequence sum. 2) Pick/not pick choices.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| DP / LIS                                                                          | M | [](https://leetcode.com/problems/longest-increasing-subsequence/)[300](https://leetcode.com/problems/longest-increasing-subsequence/)                                                                                                                    | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/LIS/LC300-longestIncreasingSubsequence.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/LIS/LC300-longestIncreasingSubsequence.py)                                 | Longest Increasing Subsequence (Memoization)                                | We use an extra index prev_i to keep track of what the previous number in our sequence was to maintain the increasing order. If prev_i is -1 (the first subproblem) or nums[i] > nums[prev_i], include it in our subsequence, otherwise the take case is 0. The As for the take case, we just recurse on the next index. Since we are keeping track of a previous index, our first case must be something out of bounds. So we need to shift our index we use to access the dp array for prev_i by 1 to the right. To do this, allocate n space for the prev_i columns in the dp array and every time dp[i][prev_i] is accessed, change it to dp[i][prev_i+1]. TABULATION 2D - We don't have to explicitly fill the base case cells because they are already set to 0 on initialization. Also note that for prev_index, our possible choices for each step for prev_i is between i-1 and -1 since prev_i must be less than i. We initialize dp to n+1 \* n+1 because for the take case we are accessing i + 1 at the n-1 row/col cell (dp[i+1][i+1]). TABULATION 1D - NOTE\*\*\*This solution will be REQUIRED if you want to trace back the LIS to get the elements.\*\*\* Use a parent array 'par' to backtrack from the last number in the LIS.                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) Get the longest increasing subsequence of an array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Kadane's Algorithm                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| DP - 1D                                                                           | M | [](https://leetcode.com/problems/maximum-product-subarray/)[152](https://leetcode.com/problems/maximum-product-subarray/)                                                                                                                                |                                                                                                                                                                                                                                                                                      | Maximum Product Subarray                                                    | Similar to kadanes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Concept: 1) To get maximum product subarray, keep track of current min and current maximum products of current subarray.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| DP - 1D                                                                           | M | [](https://leetcode.com/problems/maximum-subarray/)[53](https://leetcode.com/problems/maximum-subarray/)                                                                                                                                                 | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Subsequences/LC53-maximumSubarray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Subsequences/LC53-maximumSubarray.py)                                           | Maximum Subarray                                                            | For each index, we choose to either include the previous subarray's sum into the current sum, or the current sum is just the number at this index, similar to pick/not pick.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Concept: Kadane's algorithm                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Partition                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| DP - 1D                                                                           | M | [](https://leetcode.com/problems/word-break/)[139](https://leetcode.com/problems/word-break/)                                                                                                                                                            |                                                                                                                                                                                                                                                                                      | Word Break                                                                  | c                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Concept: 1) Determine if a string can be partitioned into substrings from a set of given strings.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| DP - 1D                                                                           | M | [](https://leetcode.com/problems/decode-ways/)[91](https://leetcode.com/problems/decode-ways/)                                                                                                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/String/LC91-decodeWays.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/String/LC91-decodeWays.py)                                                                 | Decode Ways                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Partition a string into valid substrings based on the constraints. 2) Count the number of valid partitions.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| DP - Partition                                                                    | H | [](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/)[1547](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/)                                                                                                                         |                                                                                                                                                                                                                                                                                      | Minimum Cost to Cut a Stick                                                 | Similars: 312, 1000, 1039.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Concept: 1) Get optimal permutation. 2) Use indices of left and right to track current interval.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Knapsack                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Description: Closely related to the Subsequence subpattern, except we have an additional weight constraint. Given N items and W max weight, pick items to maximize, minimize or count some goal state. The amount of times we can use each item determines if it is a bounded or unbounded knapsack algorithm.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| DP - Subsequence / Target                                                         | M | [](https://leetcode.com/problems/coin-change/)[322](https://leetcode.com/problems/coin-change/)                                                                                                                                                          | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Subsequences/LC322-coinChange.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Subsequences/LC322-coinChange.py)                                                   | Coin Change (Memoization)                                                   | When you have multiple/infinite supply of something like this problem, on the take case we never decrease the index. This is a counting problem where the choice in itself to pick a coin adds 1 to the count (So we do take = 1 + helper(i, w-arr[i]). There are other count DP problems like "Count Subsets with Sum K" where the counting is done with 0s or 1s in the base cases so we do take = helper(i, w-arr[i]). The other difference is in minimizing/maximizing vs just counting. We return infinite values in the base cases in min/max problems and do min(take, not_take). For pure counting problems, we return 0 or 1 values in the base cases and do take + not_take. For this counting problem, our base case at i == 0 must return the number of coins we can pick from the current denomination to reach 0 weight (if the weight is divisible by the denomination) or infinity otherwise. Tabulation - For the DP table for all 2D problems, our rows are the index we are at in the problem space and the columns are the weight/target. For the base case translation, we don't have to worry about the w < 0 case because that is handled in the double for loop. As for the i == 0 case, we fill every i == 0 cell for every weight (amount) in range 0 to amount + 1. If the weight (amount) is divisible by the first coin value (coins[0]), we set that dp table entry to weight (amount) // coins[0]. Otherwise, we cannot add a multiple of the 1st coin to get to this weight, so we seed this dp entry with float('inf').                                                                                                        | Concept: 1) Unbounded knapsack. 2) Get minimum number of choices needed to get to a target sum with choice weight constraint. 3) Pick/not pick choices.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| DP / Subsequence / Target                                                         | M | [](https://leetcode.com/problems/target-sum/)[494](https://leetcode.com/problems/target-sum/)                                                                                                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Subsequences/LC494-targetSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Subsequences/LC494-targetSum.py)                                                     | Target Sum (Memoization)                                                    | We are counting the number of ways we can assign signs to the numbers to get to the target, so this is the "count number of ways" subpattern of DP. This is essentially the "Count Partitions with Given Difference" problem where we try to get two subsets whose difference is the target sum.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Concept: 1) 0/1 knapsack. 2) Count the number of different ways we can get to a target sum. 3) Addition/subtraction choices.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| DP / Subsequence / Target                                                         | M | [](https://leetcode.com/problems/partition-equal-subset-sum/)[416](https://leetcode.com/problems/partition-equal-subset-sum/)                                                                                                                            | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Subsequences/LC416-partitionEqualSubsetSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Subsequences/LC416-partitionEqualSubsetSum.py)                         | Partition Equal Subset Sum                                                  | This is essentially the same problem as Subset Sum Equal to K. The only difference is we have to figure out if the array can be split into two partitions of the same subset sum. To check this, just get the sum of the array, divide by 2 to get our target sum and run Subset Sum Equal to K on this new target sum. If the original array sum is not divisible by 2, we can return False early. Tabulation - For problems where we are iterating through the entire range of the first parameter and the entire range of the second parameter, we have to make sure we are not overwriting the first for loop's cells that were seeded. So for the second for loop we iterate for k in range(1, k+1) to skip the 0th column that has already been seeded. If we didn't do this, i == 0 and k == 0 would be False when it should be True.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Concept: 1) Determine if a target subsequence sum is possible. 2) Pick/not pick choices.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Matrix                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Express state as (i, j) where i and j are the indices of the matrix (row, column).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Dp - Rectangle                                                                    | M | [](https://leetcode.com/problems/count-square-submatrices-with-all-ones/)[1277](https://leetcode.com/problems/count-square-submatrices-with-all-ones/)                                                                                                   |                                                                                                                                                                                                                                                                                      | Count Square Submatrices with All Ones                                      | Same concept as LC 221.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Concept: 1) Get count of squares you can make of a value. 2) Square count is current cell + minimum of top, left and top-left cells.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| DP / Matrix                                                                       | M | [](https://leetcode.com/problems/unique-paths/)[62](https://leetcode.com/problems/unique-paths/)                                                                                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Matrix/LC62-uniquePaths.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Matrix/LC62-uniquePaths.py)                                                               | Unique Paths                                                                | Subpattern: Count Paths. This means we are adding up choices (not taking max/min or True/False). We express the index as (I, j) where i is the row and j is the column. F(I,j) says how many ways we can travel from (0, 0) to (I,j). For base case of counting ways, return 1 if we are in the starting cell and 0 if we are out of bounds. 'Up' and 'Left' signify the number of ways to get to the cell above us and to the left of us respectively. So the number of ways to get to the current cell will be up + left. Tabulation - Why do we not do base cases for I < 0 or j < 0 for tabulation? Because we will never have I or j be less than 0 since we are going bottom-up. Why are the 0th row and 0th column's cells all seeded with the value 1? Because we use these as our base cases. We need values we can access that are in bounds of the dp table (can't access -1 for row/col since dp table indices start at 0), so we seed the first row and col and iterate in the double for loop starting at 1 for row/col so we can look back 1 without trying to access the dp table out of bounds. Conveniently, since we can only go down and right at each cell, the 0th row and 0th column will always only have 1 way to each of those cells. Think about how you can only get to those cells in 1 way.                                                                                                                                                                                                                                                                                                                                       | Concept: 1) Count the number of different ways to get to a target cell. 2) Move down/move left choices.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| DP / Matrix                                                                       | H | [](https://leetcode.com/problems/cherry-pickup-ii/)[1463](https://leetcode.com/problems/cherry-pickup-ii/)                                                                                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Matrix/LC1463-cherryPickupII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Matrix/LC1463-cherryPickupII.py)                                                     | Cherry Pickup II                                                            | We can't do each traversal individually easily because we would have to keep track of which cell the robots' paths have in common. For fixed starting point and variable ending point problems, it is always recommended to start from the fixed starting point for memoization. So we write our recursion/iteration starting from the fixed position. This is a 3D matrix cache problem because we have 3 changing parameters: i, j1, j2 where j1 is for bot1 and j2 is for bot2. IMPORTANT NOTE: If out of bounds can ever happen, always write this base case first! But it is always good practice to have the cache lookup base case condition as the last base case. TABULATION - Since we did memoization starting from the first row, we will start tabulation from the bottom row. For the base case translation, we seed the dp table for the last row with every possible combination. Then for the triple for loops, we have a for loop for i starting at the second to last row and two for loops for the j positions.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Get the maximum path to a target cell. 2) Two sources. 3) Variable ending points.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | String Matching                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Express state as (i, j) where i and j are the indices of the two strings. Base case for string matching often involves index = -1 because this signifies that the character at index 0 was checked. This is of course without an index shift.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| DP / String                                                                       | H | [](https://leetcode.com/problems/edit-distance/)[72](https://leetcode.com/problems/edit-distance/)                                                                                                                                                       | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/String/LC72-editDistance.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/String/LC72-editDistance.py)                                                             | Edit Distance                                                               | This is similar to the problem "Min number of deletions and insertions", but adds an extra layer of complexity with the ability to replace characters with any other character. So we do string matching instead. If the characters do not match we can :insert a character, delete a character or replace-match. We are trying to find all ways and take the minimum. Cases: 1) Strings match, so 0 + f(i-1, j-1). 2) Strings don't match and we insert the matching char at j's index in front of i's position so we don't have to move i, so 1 + f(i, j-1). 3) Strings don't match and we delete the char at index i, so 1 + f(i-1, j). 4) Strings don't match and we replace the char at index i to equal char at index j, so 1 + f(i-1, j-1). Then we return the min of al of these. For the base cases: If i < 0, we have j + 1 positions left to match, so we return j + 1. If j < 0, we have i + 1 positions left that we don't need, so we return i + 1. TABULATION - The reason we shift the index is because we want to be able to use the i < 0 and j < 0 base case for the memoization and encode it into the dp array. But we can't encode negative indices into a dp array since the indexing starts at 0. So we declare a dp matrix of size m + 1 \* n + 1, seed the i = 0 and j = 0 row/col with 0 and then do the bottom-up computation using previously computed values. The only other change we need to do is when comparing the ith and jth characters, we check s[i - 1] == t[j - 1] to account for this shift and return dp[m][n].                                                                                                      | Concept: 1) Get the minimum operations to convert the first string to the second string. 2) Skip or insert/delete/replace choices.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| DP / String                                                                       | H | [](https://leetcode.com/problems/wildcard-matching/)[44](https://leetcode.com/problems/wildcard-matching/)                                                                                                                                               | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/String/LC44-wildcardMatching.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/String/LC44-wildcardMatching.py)                                                     | Wildcard Matching                                                           | ? matches with a single character. \* matches with 0 or more. There are two possibilities for base cases: string s gets exhausted or string t gets exhausted. For this problem if I < 0 AND j < 0, both are exhausted so we return True. If I >= 0 and j < 0 meaning we still have elements to match in s, we return False (because we NEED characters to match to in t). If i < 0 and j >= 0, s is exhausted but we still have characters in t. If all characters in t are '\*', we can make the choice of not matching the '\*' character and thus can return True. But if ANY character left in t is not a '\*', we have to return False. For the recursive procedure, we have 3 cases: Case 1: characters match or jth char in t is '?'. If so, take both chars and call helper(i-1, j-1). Case 2: jth char in t is '\*'. Then we do two cases: take ith char and do helper(i-1, j) or take jth char and do helper(i, j-1). (Can also do 3rd case where we take both but not needed). Case 3: Chars don't match, return False. TABULATION - The reason we shift the index is because we want to be able to use the i < 0 and j < 0 base case for the memoization and encode it into the dp array. But we can't encode negative indices into a dp array since the indexing starts at 0. So we declare a dp matrix of size m + 1 \* n + 1, seed the i = 0 and j = 0 row/col with 0 and then do the bottom-up computation using previously computed values. The only other change we need to do is when comparing the ith and jth characters, we check s[i-1] and t[i-1] as the current chars we are looking at to account for this shift and return dp[m][n]. | Concept: 1) Determine if the first string can be matched with the second string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| DP / String                                                                       | M | [](https://leetcode.com/problems/longest-common-subsequence/)[1143](https://leetcode.com/problems/longest-common-subsequence/)                                                                                                                           | [](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Subsequences/LC1143-longestCommonSubsequence.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Dynamic%20Programming/Subsequences/LC1143-longestCommonSubsequence.py)                     | Longest Common Subsequence                                                  | In subsequence array problems, it was always "pick and not pick" choices, but for strings it's "match or not match". For our recursive procedure, if we don't match, we have to check possible matches of decreasing either index, so take max(f(index1 - 1, index2), f(index1, index2 -1). And if we match, we take 1 + f(index1 - 1, index2 - 1). For the base case: if either index is less than 0, return 0. For expressing our state in terms of index, we have to use two indices because we cannot track the state of both strings with one index. So f(2, 5) signifies "LCS of string 1 from 0 to 2 and string 2 from 0 to 5". TABULATION - The reason we shift the index is because we want to be able to use the i < 0 and j < 0 base case for the memoization and encode it into the dp array. But we can't encode negative indices into a dp array since the indexing starts at 0. So we declare a dp matrix of size m + 1 \* n + 1, seed the i = 0 and j = 0 row/col with 0 and then do the bottom-up computation using previously computed values. The only other change we need to do is when comparing the ith and jth characters, we check text1[i - 1] == text2[j - 1] to account for this shift. And our answer will be in dp[m][n] instead of dp[m-1][n-1].                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Get the longest common subsequence between two strings. 2)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Bit Manipulation                                                                  |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Flip Bits                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Description:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Bit Manipulation                                                                  | E | [](https://leetcode.com/problems/number-complement/description/)[476](https://leetcode.com/problems/number-complement/description/)                                                                                                                      | [](https://github.com/BrandonKenter/Solutions/blob/main/Bit%20Manipulation/LC476-numberComplement.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Bit%20Manipulation/LC476-numberComplement.py)                                                                       | Number Complement                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept:1) Use XOR bitwise operation to flip the bits of a number.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Bit Manipulation                                                                  | E | [](https://leetcode.com/problems/minimum-bit-flips-to-convert-number/)[2220](https://leetcode.com/problems/minimum-bit-flips-to-convert-number/)                                                                                                         | [](https://github.com/BrandonKenter/Solutions/blob/main/Bit%20Manipulation/LC2220-minimumBitFlipsToConvertNumber.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Bit%20Manipulation/LC2220-minimumBitFlipsToConvertNumber.py)                                         | Minimum Bit Flips to Convert Number                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use XOR to count bit differences between two numbers' binary representations.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Count Bits                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Description:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Bit Manipulation                                                                  | E | [](https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/)[1356](https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/)                                                                                                     |                                                                                                                                                                                                                                                                                      | Sort Integers by The Number of 1 Bits                                       | Only really unique is testing custom sort function.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Concept: 1) Casting integer to binary string to count bits. 2) Custom sorting function.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Cancel Duplicates                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Description:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Bit Manipulation                                                                  | E | [](https://leetcode.com/problems/single-number/)[136](https://leetcode.com/problems/single-number/)                                                                                                                                                      |                                                                                                                                                                                                                                                                                      | Single Number                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) XOR each integer in an array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                                                                   |   |                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                      |                                                                             | Set Bits                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Description:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Bit Manipulation                                                                  | E | [](https://leetcode.com/problems/reverse-bits/)[190](https://leetcode.com/problems/reverse-bits/)                                                                                                                                                        |                                                                                                                                                                                                                                                                                      | Reverse Bits                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Concept: 1) Use OR bitwise operation. 2) Reverse bits in an integer by doing a linear traversal with bit shifts.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
